(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function () {
    'use strict';

    var inp, out, cm, tree;

    var parse = require('shift-parser').default,
    redrom = require('./redrom');
        // naming = require('./naming');

    inp = document.getElementById('input');
    out = document.getElementById('output');
    inp.value = localStorage.shiftAST || 'function add (a, b) {\n  [x, y] = [a, b];\n}';

    function refresh () {
        var v;
        v = cm.getValue();
        tree = parse(v);
        // naming(tree);
        localStorage.shiftAST = v;
        out.innerHTML = redrom(tree);
    }

    cm = CodeMirror.fromTextArea(
        inp,
        {
            mode: 'javascript',
            lineNumbers: true,
            indentUnit: 2,
            tabSize: 2,
            matchBrackets: true,
            autoCloseBrackets: true,
            highlightSelectionMatche: true,
            autofocus: true
        }
    );
    cm.on('change', function () {
        setTimeout(refresh, 750);
    });
    refresh();
})();

/* global console, CodeMirror */

},{"./redrom":8,"shift-parser":4}],2:[function(require,module,exports){
"use strict";

var _extends = function (child, parent) {
  child.prototype = Object.create(parent.prototype, {
    constructor: {
      value: child,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  child.__proto__ = parent;
};

var Node = function Node() {};

exports.Node = Node;
var Directive = (function (Node) {
  var Directive = function Directive() {
    Node.apply(this, arguments);
  };

  _extends(Directive, Node);

  return Directive;
})(Node);

exports.Directive = Directive;
var Statement = (function (Node) {
  var Statement = function Statement() {
    Node.apply(this, arguments);
  };

  _extends(Statement, Node);

  return Statement;
})(Node);

exports.Statement = Statement;
var IterationStatement = (function (Statement) {
  var IterationStatement = function IterationStatement() {
    Statement.apply(this, arguments);
  };

  _extends(IterationStatement, Statement);

  return IterationStatement;
})(Statement);

exports.IterationStatement = IterationStatement;
var Expression = (function (Node) {
  var Expression = function Expression() {
    Node.apply(this, arguments);
  };

  _extends(Expression, Node);

  return Expression;
})(Node);

exports.Expression = Expression;
var PrimaryExpression = (function (Expression) {
  var PrimaryExpression = function PrimaryExpression() {
    Expression.apply(this, arguments);
  };

  _extends(PrimaryExpression, Expression);

  return PrimaryExpression;
})(Expression);

exports.PrimaryExpression = PrimaryExpression;
var LiteralExpression = (function (PrimaryExpression) {
  var LiteralExpression = function LiteralExpression() {
    PrimaryExpression.apply(this, arguments);
  };

  _extends(LiteralExpression, PrimaryExpression);

  return LiteralExpression;
})(PrimaryExpression);

exports.LiteralExpression = LiteralExpression;
var UnaryExpression = (function (Expression) {
  var UnaryExpression = function UnaryExpression(operand) {
    this.operand = operand;
  };

  _extends(UnaryExpression, Expression);

  return UnaryExpression;
})(Expression);

exports.UnaryExpression = UnaryExpression;
var MemberExpression = (function (Expression) {
  var MemberExpression = function MemberExpression(object) {
    this.object = object;
  };

  _extends(MemberExpression, Expression);

  return MemberExpression;
})(Expression);

exports.MemberExpression = MemberExpression;
var ObjectProperty = (function (Node) {
  var ObjectProperty = function ObjectProperty(name) {
    this.name = name;
  };

  _extends(ObjectProperty, Node);

  return ObjectProperty;
})(Node);

exports.ObjectProperty = ObjectProperty;
var AccessorProperty = (function (ObjectProperty) {
  var AccessorProperty = function AccessorProperty(name, body) {
    ObjectProperty.call(this, name);
    this.body = body;
  };

  _extends(AccessorProperty, ObjectProperty);

  return AccessorProperty;
})(ObjectProperty);

exports.AccessorProperty = AccessorProperty;
var FunctionBody = (function (Node) {
  var FunctionBody = function FunctionBody(directives, statements) {
    this.type = "FunctionBody";
    this.directives = directives;
    this.statements = statements;
  };

  _extends(FunctionBody, Node);

  return FunctionBody;
})(Node);

exports.FunctionBody = FunctionBody;
var FunctionDeclaration = (function (Statement) {
  var FunctionDeclaration = function FunctionDeclaration(name, parameters, body) {
    this.type = "FunctionDeclaration";
    this.name = name;
    this.parameters = parameters;
    this.body = body;
  };

  _extends(FunctionDeclaration, Statement);

  return FunctionDeclaration;
})(Statement);

exports.FunctionDeclaration = FunctionDeclaration;
var FunctionExpression = (function (PrimaryExpression) {
  var FunctionExpression = function FunctionExpression(name, parameters, body) {
    this.type = "FunctionExpression";
    this.name = name;
    this.parameters = parameters;
    this.body = body;
  };

  _extends(FunctionExpression, PrimaryExpression);

  return FunctionExpression;
})(PrimaryExpression);

exports.FunctionExpression = FunctionExpression;
var ObjectExpression = (function (PrimaryExpression) {
  var ObjectExpression = function ObjectExpression(properties) {
    this.type = "ObjectExpression";
    this.properties = properties;
  };

  _extends(ObjectExpression, PrimaryExpression);

  return ObjectExpression;
})(PrimaryExpression);

exports.ObjectExpression = ObjectExpression;
var Getter = (function (AccessorProperty) {
  var Getter = function Getter(name, body) {
    this.type = "Getter";
    AccessorProperty.call(this, name, body);
  };

  _extends(Getter, AccessorProperty);

  return Getter;
})(AccessorProperty);

exports.Getter = Getter;
var Setter = (function (AccessorProperty) {
  var Setter = function Setter(name, parameter, body) {
    this.type = "Setter";
    AccessorProperty.call(this, name, body);
    this.parameter = parameter;
  };

  _extends(Setter, AccessorProperty);

  return Setter;
})(AccessorProperty);

exports.Setter = Setter;
var DataProperty = (function (ObjectProperty) {
  var DataProperty = function DataProperty(name, expression) {
    this.type = "DataProperty";
    ObjectProperty.call(this, name);
    this.expression = expression;
  };

  _extends(DataProperty, ObjectProperty);

  return DataProperty;
})(ObjectProperty);

exports.DataProperty = DataProperty;
var PropertyName = (function (Node) {
  var PropertyName = function PropertyName(kind, value) {
    this.type = "PropertyName";
    this.kind = kind;
    this.value = value;
  };

  _extends(PropertyName, Node);

  return PropertyName;
})(Node);

exports.PropertyName = PropertyName;
var LiteralBooleanExpression = (function (LiteralExpression) {
  var LiteralBooleanExpression = function LiteralBooleanExpression(value) {
    this.type = "LiteralBooleanExpression";
    this.value = value;
  };

  _extends(LiteralBooleanExpression, LiteralExpression);

  return LiteralBooleanExpression;
})(LiteralExpression);

exports.LiteralBooleanExpression = LiteralBooleanExpression;
var LiteralNullExpression = (function (LiteralExpression) {
  var LiteralNullExpression = function LiteralNullExpression() {
    this.type = "LiteralNullExpression";
  };

  _extends(LiteralNullExpression, LiteralExpression);

  return LiteralNullExpression;
})(LiteralExpression);

exports.LiteralNullExpression = LiteralNullExpression;
var LiteralNumericExpression = (function (LiteralExpression) {
  var LiteralNumericExpression = function LiteralNumericExpression(value) {
    this.type = "LiteralNumericExpression";
    this.value = value;
  };

  _extends(LiteralNumericExpression, LiteralExpression);

  return LiteralNumericExpression;
})(LiteralExpression);

exports.LiteralNumericExpression = LiteralNumericExpression;
var LiteralRegExpExpression = (function (LiteralExpression) {
  var LiteralRegExpExpression = function LiteralRegExpExpression(value) {
    this.type = "LiteralRegExpExpression";
    this.value = value;
  };

  _extends(LiteralRegExpExpression, LiteralExpression);

  return LiteralRegExpExpression;
})(LiteralExpression);

exports.LiteralRegExpExpression = LiteralRegExpExpression;
var LiteralStringExpression = (function (LiteralExpression) {
  var LiteralStringExpression = function LiteralStringExpression(value) {
    this.type = "LiteralStringExpression";
    this.value = value;
  };

  _extends(LiteralStringExpression, LiteralExpression);

  return LiteralStringExpression;
})(LiteralExpression);

exports.LiteralStringExpression = LiteralStringExpression;
var ArrayExpression = (function (PrimaryExpression) {
  var ArrayExpression = function ArrayExpression(elements) {
    this.type = "ArrayExpression";
    this.elements = elements;
  };

  _extends(ArrayExpression, PrimaryExpression);

  return ArrayExpression;
})(PrimaryExpression);

exports.ArrayExpression = ArrayExpression;
var AssignmentExpression = (function (Expression) {
  var AssignmentExpression = function AssignmentExpression(operator, binding, expression) {
    this.type = "AssignmentExpression";
    this.operator = operator;
    this.binding = binding;
    this.expression = expression;
  };

  _extends(AssignmentExpression, Expression);

  return AssignmentExpression;
})(Expression);

exports.AssignmentExpression = AssignmentExpression;
var BinaryExpression = (function (Expression) {
  var BinaryExpression = function BinaryExpression(operator, left, right) {
    this.type = "BinaryExpression";
    this.operator = operator;
    this.left = left;
    this.right = right;
  };

  _extends(BinaryExpression, Expression);

  return BinaryExpression;
})(Expression);

exports.BinaryExpression = BinaryExpression;
var CallExpression = (function (Expression) {
  var CallExpression = function CallExpression(callee, args) {
    this.type = "CallExpression";
    this.callee = callee;
    this.arguments = args;
  };

  _extends(CallExpression, Expression);

  return CallExpression;
})(Expression);

exports.CallExpression = CallExpression;
var ComputedMemberExpression = (function (MemberExpression) {
  var ComputedMemberExpression = function ComputedMemberExpression(object, expression) {
    this.type = "ComputedMemberExpression";
    MemberExpression.call(this, object);
    this.expression = expression;
  };

  _extends(ComputedMemberExpression, MemberExpression);

  return ComputedMemberExpression;
})(MemberExpression);

exports.ComputedMemberExpression = ComputedMemberExpression;
var ConditionalExpression = (function (Expression) {
  var ConditionalExpression = function ConditionalExpression(test, consequent, alternate) {
    this.type = "ConditionalExpression";
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  };

  _extends(ConditionalExpression, Expression);

  return ConditionalExpression;
})(Expression);

exports.ConditionalExpression = ConditionalExpression;
var IdentifierExpression = (function (PrimaryExpression) {
  var IdentifierExpression = function IdentifierExpression(identifier) {
    this.type = "IdentifierExpression";
    this.identifier = identifier;
  };

  _extends(IdentifierExpression, PrimaryExpression);

  return IdentifierExpression;
})(PrimaryExpression);

exports.IdentifierExpression = IdentifierExpression;
var NewExpression = (function (Expression) {
  var NewExpression = function NewExpression(callee, args) {
    this.type = "NewExpression";
    this.callee = callee;
    this.arguments = args;
  };

  _extends(NewExpression, Expression);

  return NewExpression;
})(Expression);

exports.NewExpression = NewExpression;
var PostfixExpression = (function (UnaryExpression) {
  var PostfixExpression = function PostfixExpression(operand, operator) {
    this.type = "PostfixExpression";
    UnaryExpression.call(this, operand);
    this.operator = operator;
  };

  _extends(PostfixExpression, UnaryExpression);

  return PostfixExpression;
})(UnaryExpression);

exports.PostfixExpression = PostfixExpression;
var PrefixExpression = (function (UnaryExpression) {
  var PrefixExpression = function PrefixExpression(operator, operand) {
    this.type = "PrefixExpression";
    UnaryExpression.call(this, operand);
    this.operator = operator;
  };

  _extends(PrefixExpression, UnaryExpression);

  return PrefixExpression;
})(UnaryExpression);

exports.PrefixExpression = PrefixExpression;
var StaticMemberExpression = (function (MemberExpression) {
  var StaticMemberExpression = function StaticMemberExpression(object, property) {
    this.type = "StaticMemberExpression";
    MemberExpression.call(this, object);
    this.property = property;
  };

  _extends(StaticMemberExpression, MemberExpression);

  return StaticMemberExpression;
})(MemberExpression);

exports.StaticMemberExpression = StaticMemberExpression;
var ThisExpression = (function (PrimaryExpression) {
  var ThisExpression = function ThisExpression() {
    this.type = "ThisExpression";
  };

  _extends(ThisExpression, PrimaryExpression);

  return ThisExpression;
})(PrimaryExpression);

exports.ThisExpression = ThisExpression;
var BlockStatement = (function (Statement) {
  var BlockStatement = function BlockStatement(block) {
    this.type = "BlockStatement";
    this.block = block;
  };

  _extends(BlockStatement, Statement);

  return BlockStatement;
})(Statement);

exports.BlockStatement = BlockStatement;
var BreakStatement = (function (Statement) {
  var BreakStatement = function BreakStatement(label) {
    this.type = "BreakStatement";
    this.label = label;
  };

  _extends(BreakStatement, Statement);

  return BreakStatement;
})(Statement);

exports.BreakStatement = BreakStatement;
var ContinueStatement = (function (Statement) {
  var ContinueStatement = function ContinueStatement(label) {
    this.type = "ContinueStatement";
    this.label = label;
  };

  _extends(ContinueStatement, Statement);

  return ContinueStatement;
})(Statement);

exports.ContinueStatement = ContinueStatement;
var DebuggerStatement = (function (Statement) {
  var DebuggerStatement = function DebuggerStatement() {
    this.type = "DebuggerStatement";
  };

  _extends(DebuggerStatement, Statement);

  return DebuggerStatement;
})(Statement);

exports.DebuggerStatement = DebuggerStatement;
var DoWhileStatement = (function (IterationStatement) {
  var DoWhileStatement = function DoWhileStatement(body, test) {
    this.type = "DoWhileStatement";
    this.body = body;
    this.test = test;
  };

  _extends(DoWhileStatement, IterationStatement);

  return DoWhileStatement;
})(IterationStatement);

exports.DoWhileStatement = DoWhileStatement;
var EmptyStatement = (function (Statement) {
  var EmptyStatement = function EmptyStatement() {
    this.type = "EmptyStatement";
  };

  _extends(EmptyStatement, Statement);

  return EmptyStatement;
})(Statement);

exports.EmptyStatement = EmptyStatement;
var ExpressionStatement = (function (Statement) {
  var ExpressionStatement = function ExpressionStatement(expression) {
    this.type = "ExpressionStatement";
    this.expression = expression;
  };

  _extends(ExpressionStatement, Statement);

  return ExpressionStatement;
})(Statement);

exports.ExpressionStatement = ExpressionStatement;
var ForInStatement = (function (IterationStatement) {
  var ForInStatement = function ForInStatement(left, right, body) {
    this.type = "ForInStatement";
    this.left = left;
    this.right = right;
    this.body = body;
  };

  _extends(ForInStatement, IterationStatement);

  return ForInStatement;
})(IterationStatement);

exports.ForInStatement = ForInStatement;
var ForStatement = (function (IterationStatement) {
  var ForStatement = function ForStatement(init, test, update, body) {
    this.type = "ForStatement";
    this.init = init;
    this.test = test;
    this.update = update;
    this.body = body;
  };

  _extends(ForStatement, IterationStatement);

  return ForStatement;
})(IterationStatement);

exports.ForStatement = ForStatement;
var IfStatement = (function (Statement) {
  var IfStatement = function IfStatement(test, consequent, alternate) {
    this.type = "IfStatement";
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
  };

  _extends(IfStatement, Statement);

  return IfStatement;
})(Statement);

exports.IfStatement = IfStatement;
var LabeledStatement = (function (Statement) {
  var LabeledStatement = function LabeledStatement(label, body) {
    this.type = "LabeledStatement";
    this.label = label;
    this.body = body;
  };

  _extends(LabeledStatement, Statement);

  return LabeledStatement;
})(Statement);

exports.LabeledStatement = LabeledStatement;
var ReturnStatement = (function (Statement) {
  var ReturnStatement = function ReturnStatement(expression) {
    this.type = "ReturnStatement";
    this.expression = expression;
  };

  _extends(ReturnStatement, Statement);

  return ReturnStatement;
})(Statement);

exports.ReturnStatement = ReturnStatement;
var SwitchStatement = (function (Statement) {
  var SwitchStatement = function SwitchStatement(discriminant, cases) {
    this.type = "SwitchStatement";
    this.discriminant = discriminant;
    this.cases = cases;
  };

  _extends(SwitchStatement, Statement);

  return SwitchStatement;
})(Statement);

exports.SwitchStatement = SwitchStatement;
var SwitchStatementWithDefault = (function (Statement) {
  var SwitchStatementWithDefault = function SwitchStatementWithDefault(discriminant, preDefaultCases, defaultCase, postDefaultCases) {
    this.type = "SwitchStatementWithDefault";
    this.discriminant = discriminant;
    this.preDefaultCases = preDefaultCases;
    this.defaultCase = defaultCase;
    this.postDefaultCases = postDefaultCases;
  };

  _extends(SwitchStatementWithDefault, Statement);

  return SwitchStatementWithDefault;
})(Statement);

exports.SwitchStatementWithDefault = SwitchStatementWithDefault;
var ThrowStatement = (function (Statement) {
  var ThrowStatement = function ThrowStatement(expression) {
    this.type = "ThrowStatement";
    this.expression = expression;
  };

  _extends(ThrowStatement, Statement);

  return ThrowStatement;
})(Statement);

exports.ThrowStatement = ThrowStatement;
var TryCatchStatement = (function (Statement) {
  var TryCatchStatement = function TryCatchStatement(body, catchClause) {
    this.type = "TryCatchStatement";
    this.body = body;
    this.catchClause = catchClause;
  };

  _extends(TryCatchStatement, Statement);

  return TryCatchStatement;
})(Statement);

exports.TryCatchStatement = TryCatchStatement;
var TryFinallyStatement = (function (Statement) {
  var TryFinallyStatement = function TryFinallyStatement(body, catchClause, finalizer) {
    this.type = "TryFinallyStatement";
    this.body = body;
    this.catchClause = catchClause;
    this.finalizer = finalizer;
  };

  _extends(TryFinallyStatement, Statement);

  return TryFinallyStatement;
})(Statement);

exports.TryFinallyStatement = TryFinallyStatement;
var VariableDeclarationStatement = (function (Statement) {
  var VariableDeclarationStatement = function VariableDeclarationStatement(declaration) {
    this.type = "VariableDeclarationStatement";
    this.declaration = declaration;
  };

  _extends(VariableDeclarationStatement, Statement);

  return VariableDeclarationStatement;
})(Statement);

exports.VariableDeclarationStatement = VariableDeclarationStatement;
var WhileStatement = (function (IterationStatement) {
  var WhileStatement = function WhileStatement(test, body) {
    this.type = "WhileStatement";
    this.test = test;
    this.body = body;
  };

  _extends(WhileStatement, IterationStatement);

  return WhileStatement;
})(IterationStatement);

exports.WhileStatement = WhileStatement;
var WithStatement = (function (Statement) {
  var WithStatement = function WithStatement(object, body) {
    this.type = "WithStatement";
    this.object = object;
    this.body = body;
  };

  _extends(WithStatement, Statement);

  return WithStatement;
})(Statement);

exports.WithStatement = WithStatement;
var UnknownDirective = (function (Directive) {
  var UnknownDirective = function UnknownDirective(value) {
    this.type = "UnknownDirective";
    this.value = value;
  };

  _extends(UnknownDirective, Directive);

  return UnknownDirective;
})(Directive);

exports.UnknownDirective = UnknownDirective;
var UseStrictDirective = (function (Directive) {
  var UseStrictDirective = function UseStrictDirective() {
    this.type = "UseStrictDirective";
  };

  _extends(UseStrictDirective, Directive);

  return UseStrictDirective;
})(Directive);

exports.UseStrictDirective = UseStrictDirective;
var Block = (function (Node) {
  var Block = function Block(statements) {
    this.type = "Block";
    this.statements = statements;
  };

  _extends(Block, Node);

  return Block;
})(Node);

exports.Block = Block;
var CatchClause = (function (Node) {
  var CatchClause = function CatchClause(binding, body) {
    this.type = "CatchClause";
    this.binding = binding;
    this.body = body;
  };

  _extends(CatchClause, Node);

  return CatchClause;
})(Node);

exports.CatchClause = CatchClause;
var Identifier = (function (Node) {
  var Identifier = function Identifier(name) {
    this.type = "Identifier";
    this.name = name;
  };

  _extends(Identifier, Node);

  return Identifier;
})(Node);

exports.Identifier = Identifier;
var Script = (function (Node) {
  var Script = function Script(body) {
    this.type = "Script";
    this.body = body;
  };

  _extends(Script, Node);

  return Script;
})(Node);

exports.Script = Script;
var SwitchCase = (function (Node) {
  var SwitchCase = function SwitchCase(test, consequent) {
    this.type = "SwitchCase";
    this.test = test;
    this.consequent = consequent;
  };

  _extends(SwitchCase, Node);

  return SwitchCase;
})(Node);

exports.SwitchCase = SwitchCase;
var SwitchDefault = (function (Node) {
  var SwitchDefault = function SwitchDefault(consequent) {
    this.type = "SwitchDefault";
    this.consequent = consequent;
  };

  _extends(SwitchDefault, Node);

  return SwitchDefault;
})(Node);

exports.SwitchDefault = SwitchDefault;
var VariableDeclaration = (function (Node) {
  var VariableDeclaration = function VariableDeclaration(kind, declarators) {
    if (declarators.length < 1) throw new TypeError("VariableDeclaration declarators list must be non-empty.");
    this.type = "VariableDeclaration";
    this.kind = kind;
    this.declarators = declarators;
  };

  _extends(VariableDeclaration, Node);

  return VariableDeclaration;
})(Node);

exports.VariableDeclaration = VariableDeclaration;
var VariableDeclarator = (function (Node) {
  var VariableDeclarator = function VariableDeclarator(binding, init) {
    this.type = "VariableDeclarator";
    this.binding = binding;
    this.init = init;
  };

  _extends(VariableDeclarator, Node);

  return VariableDeclarator;
})(Node);

exports.VariableDeclarator = VariableDeclarator;

},{}],3:[function(require,module,exports){
"use strict";

var ErrorMessages = exports.ErrorMessages = {
  UNEXPECTED_TOKEN: "Unexpected token {0}",
  UNEXPECTED_ILLEGAL_TOKEN: "Unexpected token ILLEGAL",
  UNEXPECTED_NUMBER: "Unexpected number",
  UNEXPECTED_STRING: "Unexpected string",
  UNEXPECTED_IDENTIFIER: "Unexpected identifier",
  UNEXPECTED_RESERVED_WORD: "Unexpected reserved word",
  UNEXPECTED_EOS: "Unexpected end of input",
  NEWLINE_AFTER_THROW: "Illegal newline after throw",
  INVALID_REGULAR_EXPRESSION: "Invalid regular expression",
  UNTERMINATED_REG_EXP: "Invalid regular expression: missing /",
  INVALID_LHS_IN_ASSIGNMENT: "Invalid left-hand side in assignment",
  INVALID_LHS_IN_FOR_IN: "Invalid left-hand side in for-in",
  INVALID_PROPERTY_NAME: "Property name in object literal must be identifier, string literal or number literal",
  MULTIPLE_DEFAULTS_IN_SWITCH: "More than one default clause in switch statement",
  NO_CATCH_OR_FINALLY: "Missing catch or finally after try",
  UNKNOWN_LABEL: "Undefined label '{0}'",
  LABEL_REDECLARATION: "Label '{0}' has already been declared",
  ILLEGAL_CONTINUE: "Illegal continue statement",
  ILLEGAL_BREAK: "Illegal break statement",
  ILLEGAL_RETURN: "Illegal return statement",
  STRICT_MODE_WITH: "Strict mode code may not include a with statement",
  STRICT_CATCH_VARIABLE: "Catch variable may not be eval or arguments in strict mode",
  STRICT_VAR_NAME: "Variable name may not be eval or arguments in strict mode",
  STRICT_PARAM_NAME: "Parameter name eval or arguments is not allowed in strict mode",
  STRICT_PARAM_DUPE: "Strict mode function may not have duplicate parameter names",
  STRICT_FUNCTION_NAME: "Function name may not be eval or arguments in strict mode",
  STRICT_OCTAL_LITERAL: "Octal literals are not allowed in strict mode.",
  STRICT_DELETE: "Delete of an unqualified identifier in strict mode.",
  STRICT_DUPLICATE_PROPERTY: "Duplicate data property in object literal not allowed in strict mode",
  ACCESSOR_DATA_PROPERTY: "Object literal may not have data and accessor property with the same name",
  ACCESSOR_GET_SET: "Object literal may not have multiple get/set accessors with the same name",
  STRICT_LHS_ASSIGNMENT: "Assignment to eval or arguments is not allowed in strict mode",
  STRICT_LHS_POSTFIX: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
  STRICT_LHS_PREFIX: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
  STRICT_RESERVED_WORD: "Use of future reserved word in strict mode"
};

},{}],4:[function(require,module,exports){
"use strict";

var Parser = require("./parser").Parser;
function parse(code) {
  return new Parser(code).parseScript();
}
exports["default"] = parse;

},{"./parser":5}],5:[function(require,module,exports){
"use strict";

var _toArray = function (arr) {
  return Array.isArray(arr) ? arr : Array.from(arr);
};

var _extends = function (child, parent) {
  child.prototype = Object.create(parent.prototype, {
    constructor: {
      value: child,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  child.__proto__ = parent;
};

var FunctionBody = require("shift-ast").FunctionBody;
var FunctionDeclaration = require("shift-ast").FunctionDeclaration;
var FunctionExpression = require("shift-ast").FunctionExpression;
var ObjectExpression = require("shift-ast").ObjectExpression;
var Getter = require("shift-ast").Getter;
var Setter = require("shift-ast").Setter;
var DataProperty = require("shift-ast").DataProperty;
var PropertyName = require("shift-ast").PropertyName;
var LiteralBooleanExpression = require("shift-ast").LiteralBooleanExpression;
var LiteralNullExpression = require("shift-ast").LiteralNullExpression;
var LiteralNumericExpression = require("shift-ast").LiteralNumericExpression;
var LiteralRegExpExpression = require("shift-ast").LiteralRegExpExpression;
var LiteralStringExpression = require("shift-ast").LiteralStringExpression;
var ArrayExpression = require("shift-ast").ArrayExpression;
var AssignmentExpression = require("shift-ast").AssignmentExpression;
var BinaryExpression = require("shift-ast").BinaryExpression;
var CallExpression = require("shift-ast").CallExpression;
var ComputedMemberExpression = require("shift-ast").ComputedMemberExpression;
var ConditionalExpression = require("shift-ast").ConditionalExpression;
var IdentifierExpression = require("shift-ast").IdentifierExpression;
var NewExpression = require("shift-ast").NewExpression;
var PostfixExpression = require("shift-ast").PostfixExpression;
var PrefixExpression = require("shift-ast").PrefixExpression;
var StaticMemberExpression = require("shift-ast").StaticMemberExpression;
var ThisExpression = require("shift-ast").ThisExpression;
var BlockStatement = require("shift-ast").BlockStatement;
var BreakStatement = require("shift-ast").BreakStatement;
var ContinueStatement = require("shift-ast").ContinueStatement;
var DebuggerStatement = require("shift-ast").DebuggerStatement;
var DoWhileStatement = require("shift-ast").DoWhileStatement;
var EmptyStatement = require("shift-ast").EmptyStatement;
var ExpressionStatement = require("shift-ast").ExpressionStatement;
var ForInStatement = require("shift-ast").ForInStatement;
var ForStatement = require("shift-ast").ForStatement;
var IfStatement = require("shift-ast").IfStatement;
var LabeledStatement = require("shift-ast").LabeledStatement;
var ReturnStatement = require("shift-ast").ReturnStatement;
var SwitchStatement = require("shift-ast").SwitchStatement;
var SwitchStatementWithDefault = require("shift-ast").SwitchStatementWithDefault;
var ThrowStatement = require("shift-ast").ThrowStatement;
var TryCatchStatement = require("shift-ast").TryCatchStatement;
var TryFinallyStatement = require("shift-ast").TryFinallyStatement;
var VariableDeclarationStatement = require("shift-ast").VariableDeclarationStatement;
var WhileStatement = require("shift-ast").WhileStatement;
var WithStatement = require("shift-ast").WithStatement;
var UnknownDirective = require("shift-ast").UnknownDirective;
var UseStrictDirective = require("shift-ast").UseStrictDirective;
var Block = require("shift-ast").Block;
var CatchClause = require("shift-ast").CatchClause;
var Identifier = require("shift-ast").Identifier;
var Script = require("shift-ast").Script;
var SwitchCase = require("shift-ast").SwitchCase;
var SwitchDefault = require("shift-ast").SwitchDefault;
var VariableDeclaration = require("shift-ast").VariableDeclaration;
var VariableDeclarator = require("shift-ast").VariableDeclarator;
var isRestrictedWord = require("./utils").isRestrictedWord;
var isStrictModeReservedWordES5 = require("./utils").isStrictModeReservedWordES5;
var ErrorMessages = require("./errors").ErrorMessages;
var Tokenizer = require("./tokenizer")["default"];
var TokenClass = require("./tokenizer").TokenClass;
var TokenType = require("./tokenizer").TokenType;
var IdentifierToken = require("./tokenizer").IdentifierToken;
var IdentifierLikeToken = require("./tokenizer").IdentifierLikeToken;
var NumericLiteralToken = require("./tokenizer").NumericLiteralToken;
var StringLiteralToken = require("./tokenizer").StringLiteralToken;


var INIT_MASK = 1;
var GETTER_MASK = 2;
var SETTER_MASK = 4;

var STRICT_MODE_RESERVED_WORD = ["implements", "interface", "package", "private", "protected", "public", "static", "yield", "let"];

var Precedence = {
  Sequence: 0,
  Yield: 1,
  Assignment: 1,
  Conditional: 2,
  ArrowFunction: 2,
  LogicalOR: 3,
  LogicalAND: 4,
  BitwiseOR: 5,
  BitwiseXOR: 6,
  BitwiseAND: 7,
  Equality: 8,
  Relational: 9,
  BitwiseSHIFT: 10,
  Additive: 11,
  Multiplicative: 12,
  Unary: 13,
  Postfix: 14,
  Call: 15,
  New: 16,
  TaggedTemplate: 17,
  Member: 18,
  Primary: 19
};

var BinaryPrecedence = {
  "||": Precedence.LogicalOR,
  "&&": Precedence.LogicalAND,
  "|": Precedence.BitwiseOR,
  "^": Precedence.BitwiseXOR,
  "&": Precedence.BitwiseAND,
  "==": Precedence.Equality,
  "!=": Precedence.Equality,
  "===": Precedence.Equality,
  "!==": Precedence.Equality,
  "<": Precedence.Relational,
  ">": Precedence.Relational,
  "<=": Precedence.Relational,
  ">=": Precedence.Relational,
  "in": Precedence.Relational,
  "instanceof": Precedence.Relational,
  "<<": Precedence.BitwiseSHIFT,
  ">>": Precedence.BitwiseSHIFT,
  ">>>": Precedence.BitwiseSHIFT,
  "+": Precedence.Additive,
  "-": Precedence.Additive,
  "*": Precedence.Multiplicative,
  "%": Precedence.Multiplicative,
  "/": Precedence.Multiplicative };

var Parser = (function (Tokenizer) {
  var Parser = function Parser(source) {
    Tokenizer.call(this, source);
    this.labelSet = Object.create(null);
    this.allowIn = true;
    this.inIteration = false;
    this.inSwitch = false;
    this.inFunctionBody = false;
  };

  _extends(Parser, Tokenizer);

  Parser.prototype.eat = function (tokenType) {
    if (this.lookahead.type === tokenType) {
      return this.lex();
    }
  };

  Parser.prototype.expect = function (tokenType) {
    if (this.lookahead.type === tokenType) {
      return this.lex();
    }
    throw this.createUnexpected(this.lookahead);
  };

  Parser.prototype.match = function (subType) {
    return this.lookahead.type === subType;
  };

  Parser.prototype.consumeSemicolon = function () {
    // Catch the very common case first: immediately a semicolon (U+003B).
    if (this.index < this.source.length && this.source.charAt(this.index) == ";") {
      this.lex();
      return;
    }

    this.index = this.lookahead.slice.start;
    if (this.hasLineTerminatorBeforeNext) {
      return;
    }

    if (this.match(TokenType.SEMICOLON)) {
      this.lex();
      return;
    }

    if (!this.eof() && !this.match(TokenType.RBRACE)) {
      throw this.createUnexpected(this.lookahead);
    }
  };

  Parser.prototype.markLocation = function (node, startTokenIndex, endTokenIndex) {
    if (endTokenIndex === undefined) endTokenIndex = this.tokenIndex;
    // TODO: mark the source locations.
    return node;
  };

  Parser.prototype.parseScript = function () {
    var _ref = this.parseBody(true);

    var _ref2 = _toArray(_ref);

    var body = _ref2[0];
    var isStrict = _ref2[1];
    return new Script(this.markLocation(body, 0));
  };

  Parser.prototype.parseFunctionBody = function () {
    var previousStrict = this.strict;
    var startTokenIndex = this.tokenIndex;

    var oldLabelSet = this.labelSet;
    var oldInIteration = this.inIteration;
    var oldInSwitch = this.inSwitch;
    var oldInFunctionBody = this.inFunctionBody;

    this.labelSet = Object.create(null);
    this.inIteration = false;
    this.inSwitch = false;
    this.inFunctionBody = true;

    this.expect(TokenType.LBRACE);
    var _ref3 = this.parseBody();

    var _ref4 = _toArray(_ref3);

    var body = _ref4[0];
    var isStrict = _ref4[1];
    this.expect(TokenType.RBRACE);

    body = this.markLocation(body, startTokenIndex);

    this.labelSet = oldLabelSet;
    this.inIteration = oldInIteration;
    this.inSwitch = oldInSwitch;
    this.inFunctionBody = oldInFunctionBody;
    this.strict = previousStrict;
    return [body, isStrict];
  };

  Parser.prototype.parseBody = function (acceptEOF) {
    if (acceptEOF === undefined) acceptEOF = false;
    var directives = [];
    var statements = [];
    var parsingDirectives = true;
    var isStrict = this.strict;
    var firstRestricted = null;
    while (true) {
      if (acceptEOF) {
        if (this.eof()) {
          break;
        }
      } else {
        if (this.match(TokenType.RBRACE)) {
          break;
        }
      }
      var token = this.lookahead;
      var text = token.slice.text;
      var isStringLiteral = token instanceof StringLiteralToken;
      var stmt = this.parseStatement();
      if (parsingDirectives) {
        if (isStringLiteral && stmt.type === "ExpressionStatement" && stmt.expression.type === "LiteralStringExpression") {
          if (text === "\"use strict\"" || text === "'use strict'") {
            directives.push(new UseStrictDirective());
            isStrict = true;
            this.strict = true;
            if (firstRestricted != null) {
              throw this.createErrorWithToken(firstRestricted, ErrorMessages.STRICT_OCTAL_LITERAL);
            }
          } else {
            directives.push(new UnknownDirective(stmt.expression.value));
            if (firstRestricted == null && token.octal) {
              firstRestricted = token;
            }
          }
        } else {
          parsingDirectives = false;
          statements.push(stmt);
        }
      } else {
        statements.push(stmt);
      }
    }

    return [new FunctionBody(directives, statements), isStrict];
  };

  Parser.prototype.parseStatement = function () {
    var startTokenIndex = this.tokenIndex;
    if (this.eof()) {
      throw this.createUnexpected(this.lookahead);
    }
    switch (this.lookahead.type) {
      case TokenType.SEMICOLON:
        return this.markLocation(this.parseEmptyStatement(), startTokenIndex);
      case TokenType.LBRACE:
        return this.markLocation(this.parseBlockStatement(), startTokenIndex);
      case TokenType.LPAREN:
        return this.markLocation(this.parseExpressionStatement(), startTokenIndex);
      case TokenType.BREAK:
        return this.markLocation(this.parseBreakStatement(), startTokenIndex);
      case TokenType.CONTINUE:
        return this.markLocation(this.parseContinueStatement(), startTokenIndex);
      case TokenType.DEBUGGER:
        return this.markLocation(this.parseDebuggerStatement(), startTokenIndex);
      case TokenType.DO:
        return this.markLocation(this.parseDoWhileStatement(), startTokenIndex);
      case TokenType.FOR:
        return this.markLocation(this.parseForStatement(), startTokenIndex);
      case TokenType.FUNCTION:
        return this.markLocation(this.parseFunction(false), startTokenIndex);
      case TokenType.IF:
        return this.markLocation(this.parseIfStatement(), startTokenIndex);
      case TokenType.RETURN:
        return this.markLocation(this.parseReturnStatement(), startTokenIndex);
      case TokenType.SWITCH:
        return this.markLocation(this.parseSwitchStatement(), startTokenIndex);
      case TokenType.THROW:
        return this.markLocation(this.parseThrowStatement(), startTokenIndex);
      case TokenType.TRY:
        return this.markLocation(this.parseTryStatement(), startTokenIndex);
      case TokenType.VAR:
      case TokenType.LET:
      case TokenType.CONST:
        return this.markLocation(this.parseVariableDeclarationStatement(), startTokenIndex);
      case TokenType.WHILE:
        return this.markLocation(this.parseWhileStatement(), startTokenIndex);
      case TokenType.WITH:
        return this.markLocation(this.parseWithStatement(), startTokenIndex);
      default:
        {
          var expr = this.parseExpression();

          // 12.12 Labelled Statements;
          if (expr.type === "IdentifierExpression" && this.match(TokenType.COLON)) {
            this.lex();
            var key = "$" + expr.identifier.name;
            if (Object.prototype.hasOwnProperty.call(this.labelSet, key)) {
              throw this.createError(ErrorMessages.LABEL_REDECLARATION, expr.identifier.name);
            }

            this.labelSet[key] = true;
            var labeledBody = this.parseStatement();
            delete this.labelSet[key];
            return this.markLocation(new LabeledStatement(expr.identifier, labeledBody), startTokenIndex);
          } else {
            this.consumeSemicolon();
            return this.markLocation(new ExpressionStatement(expr), startTokenIndex);
          }
        }
    }
  };

  Parser.prototype.parseVariableIdentifier = function () {
    var startTokenIndex = this.tokenIndex;

    var token = this.lex();
    if (!(token instanceof IdentifierToken)) {
      throw this.createUnexpected(token);
    }

    return this.markLocation(new Identifier(token.value), startTokenIndex);
  };

  Parser.prototype.parseEmptyStatement = function () {
    this.expect(TokenType.SEMICOLON);
    return new EmptyStatement();
  };

  Parser.prototype.parseBlockStatement = function () {
    return new BlockStatement(this.parseBlock());
  };

  Parser.prototype.parseExpressionStatement = function () {
    var expr = this.parseExpression();
    this.consumeSemicolon();
    return new ExpressionStatement(expr);
  };

  Parser.prototype.parseBreakStatement = function () {
    var token = this.lookahead;
    this.expect(TokenType.BREAK);

    // Catch the very common case first: immediately a semicolon (U+003B).
    if (this.lookahead.type == TokenType.SEMICOLON) {
      this.lex();

      if (!(this.inIteration || this.inSwitch)) {
        throw this.createErrorWithToken(token, ErrorMessages.ILLEGAL_BREAK);
      }

      return new BreakStatement(null);
    }

    if (this.hasLineTerminatorBeforeNext) {
      if (!(this.inIteration || this.inSwitch)) {
        throw this.createErrorWithToken(token, ErrorMessages.ILLEGAL_BREAK);
      }

      return new BreakStatement(null);
    }

    var label = null;
    if (this.lookahead.type == TokenType.IDENTIFIER) {
      label = this.parseVariableIdentifier();

      var key = "$" + label.name;
      if (!Object.prototype.hasOwnProperty.call(this.labelSet, key)) {
        throw this.createError(ErrorMessages.UNKNOWN_LABEL, label.name);
      }
    }

    this.consumeSemicolon();

    if (label == null && !(this.inIteration || this.inSwitch)) {
      throw this.createErrorWithToken(token, ErrorMessages.ILLEGAL_BREAK);
    }

    return new BreakStatement(label);
  };

  Parser.prototype.parseContinueStatement = function () {
    var token = this.lookahead;
    this.expect(TokenType.CONTINUE);

    // Catch the very common case first: immediately a semicolon (U+003B).
    if (this.lookahead.type == TokenType.SEMICOLON) {
      this.lex();
      if (!this.inIteration) {
        throw this.createErrorWithToken(token, ErrorMessages.ILLEGAL_CONTINUE);
      }

      return new ContinueStatement(null);
    }

    if (this.hasLineTerminatorBeforeNext) {
      if (!this.inIteration) {
        throw this.createErrorWithToken(token, ErrorMessages.ILLEGAL_CONTINUE);
      }

      return new ContinueStatement(null);
    }

    var label = null;
    if (this.lookahead.type == TokenType.IDENTIFIER) {
      label = this.parseVariableIdentifier();

      var key = "$" + label.name;
      if (!Object.prototype.hasOwnProperty.call(this.labelSet, key)) {
        throw this.createError(ErrorMessages.UNKNOWN_LABEL, label.name);
      }
    }

    this.consumeSemicolon();
    if (!this.inIteration) {
      throw this.createErrorWithToken(token, ErrorMessages.ILLEGAL_CONTINUE);
    }

    return new ContinueStatement(label);
  };

  Parser.prototype.parseDebuggerStatement = function () {
    this.expect(TokenType.DEBUGGER);
    this.consumeSemicolon();
    return new DebuggerStatement();
  };

  Parser.prototype.parseDoWhileStatement = function () {
    this.expect(TokenType.DO);
    var oldInIteration = this.inIteration;
    this.inIteration = true;

    var body = this.parseStatement();
    this.inIteration = oldInIteration;

    this.expect(TokenType.WHILE);
    this.expect(TokenType.LPAREN);
    var test = this.parseExpression();
    this.expect(TokenType.RPAREN);
    if (this.match(TokenType.SEMICOLON)) {
      this.lex();
    }

    return new DoWhileStatement(body, test);
  };

  Parser.isLeftHandSide = function (expr) {
    switch (expr.type) {
      case "CallExpression":
      case "NewExpression":
      case "StaticMemberExpression":
      case "ComputedMemberExpression":
      case "ArrayExpression":
      case "FunctionExpression":
      case "IdentifierExpression":
      case "LiteralBooleanExpression":
      case "LiteralStringExpression":
      case "LiteralNullExpression":
      case "LiteralRegExpExpression":
      case "ObjectExpression":
      case "ThisExpression":
        return true;
    }
    return false;
  };

  Parser.prototype.parseForStatement = function () {
    this.expect(TokenType.FOR);
    this.expect(TokenType.LPAREN);
    var test = null;
    var right = null;
    if (this.match(TokenType.SEMICOLON)) {
      this.lex();
      if (!this.match(TokenType.SEMICOLON)) {
        test = this.parseExpression();
      }
      this.expect(TokenType.SEMICOLON);
      if (!this.match(TokenType.RPAREN)) {
        right = this.parseExpression();
      }
      return new ForStatement(null, test, right, this.getIteratorStatementEpilogue());
    } else {
      if (this.match(TokenType.VAR) || this.match(TokenType.LET)) {
        var previousAllowIn = this.allowIn;
        this.allowIn = false;
        var initDecl = this.parseVariableDeclaration();
        this.allowIn = previousAllowIn;

        if (initDecl.declarators.length === 1 && this.match(TokenType.IN)) {
          this.lex();
          right = this.parseExpression();
          return new ForInStatement(initDecl, right, this.getIteratorStatementEpilogue());
        } else {
          this.expect(TokenType.SEMICOLON);
          if (!this.match(TokenType.SEMICOLON)) {
            test = this.parseExpression();
          }
          this.expect(TokenType.SEMICOLON);
          if (!this.match(TokenType.RPAREN)) {
            right = this.parseExpression();
          }
          return new ForStatement(initDecl, test, right, this.getIteratorStatementEpilogue());
        }
      } else {
        var previousAllowIn = this.allowIn;
        this.allowIn = false;
        var init = this.parseExpression();
        this.allowIn = previousAllowIn;

        if (this.match(TokenType.IN)) {
          if (!Parser.isLeftHandSide(init)) {
            throw this.createError(ErrorMessages.INVALID_LHS_IN_FOR_IN);
          }

          this.lex();
          right = this.parseExpression();
          return new ForInStatement(init, right, this.getIteratorStatementEpilogue());
        } else {
          this.expect(TokenType.SEMICOLON);
          if (!this.match(TokenType.SEMICOLON)) {
            test = this.parseExpression();
          }
          this.expect(TokenType.SEMICOLON);
          if (!this.match(TokenType.RPAREN)) {
            right = this.parseExpression();
          }
          return new ForStatement(init, test, right, this.getIteratorStatementEpilogue());
        }
      }
    }
  };

  Parser.prototype.getIteratorStatementEpilogue = function () {
    this.expect(TokenType.RPAREN);
    var oldInIteration = this.inIteration;
    this.inIteration = true;
    var body = this.parseStatement();
    this.inIteration = oldInIteration;
    return body;
  };

  Parser.prototype.parseIfStatement = function () {
    this.expect(TokenType.IF);
    this.expect(TokenType.LPAREN);
    var test = this.parseExpression();

    this.expect(TokenType.RPAREN);
    var consequent = this.parseStatement();
    var alternate = null;
    if (this.match(TokenType.ELSE)) {
      this.lex();
      alternate = this.parseStatement();
    }
    return new IfStatement(test, consequent, alternate);
  };

  Parser.prototype.parseReturnStatement = function () {
    var argument = null;

    this.expect(TokenType.RETURN);
    if (!this.inFunctionBody) {
      throw this.createError(ErrorMessages.ILLEGAL_RETURN);
    }

    if (this.hasLineTerminatorBeforeNext) {
      return new ReturnStatement(null);
    }

    if (!this.match(TokenType.SEMICOLON)) {
      if (!this.match(TokenType.RBRACE) && !this.eof()) {
        argument = this.parseExpression();
      }
    }

    this.consumeSemicolon();
    return new ReturnStatement(argument);
  };

  Parser.prototype.parseWithStatement = function () {
    if (this.strict) {
      throw this.createError(ErrorMessages.STRICT_MODE_WITH);
    }

    this.expect(TokenType.WITH);
    this.expect(TokenType.LPAREN);
    var object = this.parseExpression();
    this.expect(TokenType.RPAREN);
    var body = this.parseStatement();

    return new WithStatement(object, body);
  };

  Parser.prototype.parseSwitchStatement = function () {
    this.expect(TokenType.SWITCH);
    this.expect(TokenType.LPAREN);
    var discriminant = this.parseExpression();
    this.expect(TokenType.RPAREN);
    this.expect(TokenType.LBRACE);

    if (this.match(TokenType.RBRACE)) {
      this.lex();
      return new SwitchStatement(discriminant, []);
    }
    var oldInSwitch = this.inSwitch;
    this.inSwitch = true;

    var cases = this.parseSwitchCases();

    if (this.match(TokenType.DEFAULT)) {
      var switchDefault = this.parseSwitchDefault();
      var postDefaultCases = this.parseSwitchCases();
      if (this.match(TokenType.DEFAULT)) {
        throw this.createError(ErrorMessages.MULTIPLE_DEFAULTS_IN_SWITCH);
      }
      this.inSwitch = oldInSwitch;
      this.expect(TokenType.RBRACE);
      return new SwitchStatementWithDefault(discriminant, cases, switchDefault, postDefaultCases);
    } else {
      this.inSwitch = oldInSwitch;
      this.expect(TokenType.RBRACE);
      return new SwitchStatement(discriminant, cases);
    }
  };

  Parser.prototype.parseSwitchCases = function () {
    var result = [];
    while (!(this.eof() || this.match(TokenType.RBRACE) || this.match(TokenType.DEFAULT))) {
      result.push(this.parseSwitchCase());
    }
    return result;
  };

  Parser.prototype.parseSwitchCase = function () {
    var startTokenIndex = this.tokenIndex;
    this.expect(TokenType.CASE);
    return this.markLocation(new SwitchCase(this.parseExpression(), this.parseSwitchCaseBody()), startTokenIndex);
  };

  Parser.prototype.parseSwitchDefault = function () {
    var startTokenIndex = this.tokenIndex;
    this.expect(TokenType.DEFAULT);
    return this.markLocation(new SwitchDefault(this.parseSwitchCaseBody()), startTokenIndex);
  };

  Parser.prototype.parseSwitchCaseBody = function () {
    this.expect(TokenType.COLON);
    return this.parseStatementListInSwitchCaseBody();
  };

  Parser.prototype.parseStatementListInSwitchCaseBody = function () {
    var result = [];
    while (!(this.eof() || this.match(TokenType.RBRACE) || this.match(TokenType.DEFAULT) || this.match(TokenType.CASE))) {
      result.push(this.parseStatement());
    }
    return result;
  };

  Parser.prototype.parseThrowStatement = function () {
    var token = this.expect(TokenType.THROW);

    if (this.hasLineTerminatorBeforeNext) {
      throw this.createErrorWithToken(token, ErrorMessages.NEWLINE_AFTER_THROW);
    }

    var argument = this.parseExpression();

    this.consumeSemicolon();

    return new ThrowStatement(argument);
  };

  Parser.prototype.parseTryStatement = function () {
    this.expect(TokenType.TRY);
    var block = this.parseBlock();

    if (this.match(TokenType.CATCH)) {
      var handler = this.parseCatchClause();
      if (this.match(TokenType.FINALLY)) {
        this.lex();
        var finalizer = this.parseBlock();
        return new TryFinallyStatement(block, handler, finalizer);
      }
      return new TryCatchStatement(block, handler);
    }

    if (this.match(TokenType.FINALLY)) {
      this.lex();
      var finalizer = this.parseBlock();
      return new TryFinallyStatement(block, null, finalizer);
    } else {
      throw this.createError(ErrorMessages.NO_CATCH_OR_FINALLY);
    }
  };

  Parser.prototype.parseVariableDeclarationStatement = function () {
    var declaration = this.parseVariableDeclaration();
    this.consumeSemicolon();
    return new VariableDeclarationStatement(declaration);
  };

  Parser.prototype.parseWhileStatement = function () {
    this.expect(TokenType.WHILE);
    this.expect(TokenType.LPAREN);
    return new WhileStatement(this.parseExpression(), this.getIteratorStatementEpilogue());
  };

  Parser.prototype.parseCatchClause = function () {
    var startTokenIndex = this.tokenIndex;

    this.expect(TokenType.CATCH);
    this.expect(TokenType.LPAREN);
    if (this.match(TokenType.RPAREN)) {
      throw this.createUnexpected(this.lookahead);
    }

    var param = this.parseVariableIdentifier();

    // 12.14.1;
    if (this.strict && isRestrictedWord(param.name)) {
      throw this.createError(ErrorMessages.STRICT_CATCH_VARIABLE);
    }

    this.expect(TokenType.RPAREN);

    var body = this.parseBlock();

    return this.markLocation(new CatchClause(param, body), startTokenIndex);
  };

  Parser.prototype.parseBlock = function () {
    var startTokenIndex = this.tokenIndex;
    this.expect(TokenType.LBRACE);

    var body = [];
    while (!this.match(TokenType.RBRACE)) {
      body.push(this.parseStatement());
    }
    this.expect(TokenType.RBRACE);

    return this.markLocation(new Block(body), startTokenIndex);
  };

  Parser.prototype.parseVariableDeclaration = function () {
    var startTokenIndex = this.tokenIndex;
    var token = this.lex();

    // Preceded by this.match(TokenSubType.VAR) || this.match(TokenSubType.LET);
    var kind = token.type == TokenType.VAR ? "var" : token.type === TokenType.CONST ? "const" : "let";
    var declarators = this.parseVariableDeclaratorList(kind);
    return this.markLocation(new VariableDeclaration(kind, declarators), startTokenIndex);
  };

  Parser.prototype.parseVariableDeclaratorList = function (kind) {
    var result = [];
    while (true) {
      result.push(this.parseVariableDeclarator(kind));
      if (!this.eat(TokenType.COMMA)) {
        return result;
      }
    }
  };

  Parser.prototype.parseVariableDeclarator = function (kind) {
    var startTokenIndex = this.tokenIndex;

    var id = this.parseVariableIdentifier();

    // 12.2.1;
    if (this.strict && isRestrictedWord(id.name)) {
      throw this.createError(ErrorMessages.STRICT_VAR_NAME);
    }

    var init = null;
    if (kind == "const") {
      this.expect(TokenType.ASSIGN);
      init = this.parseAssignmentExpression();
    } else if (this.match(TokenType.ASSIGN)) {
      this.lex();
      init = this.parseAssignmentExpression();
    }
    return this.markLocation(new VariableDeclarator(id, init), startTokenIndex);
  };

  Parser.prototype.parseExpression = function () {
    var startTokenIndex = this.tokenIndex;

    var expr = this.parseAssignmentExpression();

    if (this.match(TokenType.COMMA)) {
      while (!this.eof()) {
        if (!this.match(TokenType.COMMA)) {
          break;
        }
        this.lex();
        expr = this.markLocation(new BinaryExpression(",", expr, this.parseAssignmentExpression()), startTokenIndex);
      }
    }
    return expr;
  };

  Parser.prototype.parseAssignmentExpression = function () {
    var token = this.lookahead;
    var startTokenIndex = this.tokenIndex;

    var node = this.parseConditionalExpression();

    var isOperator = false;
    var operator = this.lookahead;
    switch (operator.type) {
      case TokenType.ASSIGN:
      case TokenType.ASSIGN_BIT_OR:
      case TokenType.ASSIGN_BIT_XOR:
      case TokenType.ASSIGN_BIT_AND:
      case TokenType.ASSIGN_SHL:
      case TokenType.ASSIGN_SHR:
      case TokenType.ASSIGN_SHR_UNSIGNED:
      case TokenType.ASSIGN_ADD:
      case TokenType.ASSIGN_SUB:
      case TokenType.ASSIGN_MUL:
      case TokenType.ASSIGN_DIV:
      case TokenType.ASSIGN_MOD:
        isOperator = true;
        break;
    }

    if (isOperator) {
      // To be permissive.
      // if (!isLeftHandSide(node)) {
      //     throw this.createError(ErrorMessages.INVALID_LHS_IN_ASSIGNMENT);
      // }

      // 11.13.1;
      if (node.type === "IdentifierExpression") {
        if (this.strict && isRestrictedWord(node.identifier.name)) {
          throw this.createErrorWithToken(token, ErrorMessages.STRICT_LHS_ASSIGNMENT);
        }
      }

      this.lex();
      var right = this.parseAssignmentExpression();
      return this.markLocation(new AssignmentExpression(operator.type.name, node, right), startTokenIndex);
    }
    return node;
  };

  Parser.prototype.parseConditionalExpression = function () {
    var startTokenIndex = this.tokenIndex;
    var expr = this.parseBinaryExpression();
    if (this.match(TokenType.CONDITIONAL)) {
      this.lex();
      var previousAllowIn = this.allowIn;
      this.allowIn = true;
      var consequent = this.parseAssignmentExpression();
      this.allowIn = previousAllowIn;
      this.expect(TokenType.COLON);
      var alternate = this.parseAssignmentExpression();
      return this.markLocation(new ConditionalExpression(expr, consequent, alternate), startTokenIndex);
    }

    return expr;
  };

  Parser.prototype.isBinaryOperator = function (type) {
    switch (type) {
      case TokenType.OR:
      case TokenType.AND:
      case TokenType.BIT_OR:
      case TokenType.BIT_XOR:
      case TokenType.BIT_AND:
      case TokenType.EQ:
      case TokenType.NE:
      case TokenType.EQ_STRICT:
      case TokenType.NE_STRICT:
      case TokenType.LT:
      case TokenType.GT:
      case TokenType.LTE:
      case TokenType.GTE:
      case TokenType.INSTANCEOF:
      case TokenType.SHL:
      case TokenType.SHR:
      case TokenType.SHR_UNSIGNED:
      case TokenType.ADD:
      case TokenType.SUB:
      case TokenType.MUL:
      case TokenType.DIV:
      case TokenType.MOD:
        return true;
      case TokenType.IN:
        return this.allowIn;
      default:
        return false;
    }
  };

  Parser.prototype.parseBinaryExpression = function () {
    var _this = this;
    var left = this.parseUnaryExpression();
    var operator = this.lookahead.type;

    var _isBinaryOperator = this.isBinaryOperator(operator);
    if (!_isBinaryOperator) {
      return left;
    }

    this.lex();
    var stack = [];
    stack.push({ startIndex: this.tokenIndex, left: left, operator: operator, precedence: BinaryPrecedence[operator.name] });
    var right = this.parseUnaryExpression();

    operator = this.lookahead.type;
    _isBinaryOperator = this.isBinaryOperator(this.lookahead.type);
    while (_isBinaryOperator) {
      var precedence = BinaryPrecedence[operator.name];
      // Reduce: make a binary expression from the three topmost entries.
      while (stack.length && (precedence <= stack[stack.length - 1].precedence)) {
        var stackItem = stack[stack.length - 1];
        var stackOperator = stackItem.operator;
        left = stackItem.left;
        stack.pop();
        right = this.markLocation(new BinaryExpression(stackOperator.name, left, right), stackItem.startIndex, this.tokenIndex);
      }

      // Shift.
      this.lex();
      stack.push({ startIndex: this.tokenIndex, left: right, operator: operator, precedence: precedence });
      right = this.parseUnaryExpression();

      operator = this.lookahead.type;
      _isBinaryOperator = this.isBinaryOperator(operator);
    }

    // Final reduce to clean-up the stack.
    return stack.reduceRight(function (expr, stackItem) {
      return _this.markLocation(new BinaryExpression(stackItem.operator.name, stackItem.left, expr), stackItem.startIndex, _this.tokenIndex);
    }, right);
  };

  Parser.isPrefixOperator = function (type) {
    switch (type) {
      case TokenType.INC:
      case TokenType.DEC:
      case TokenType.ADD:
      case TokenType.SUB:
      case TokenType.BIT_NOT:
      case TokenType.NOT:
      case TokenType.DELETE:
      case TokenType.VOID:
      case TokenType.TYPEOF:
        return true;
    }
    return false;
  };

  Parser.prototype.parseUnaryExpression = function () {
    if (this.lookahead.type.klass != TokenClass.Punctuator && this.lookahead.type.klass != TokenClass.Keyword) {
      return this.parsePostfixExpression();
    }
    var startTokenIndex = this.tokenIndex;
    var operator = this.lookahead;
    if (!Parser.isPrefixOperator(operator.type)) {
      return this.parsePostfixExpression();
    }
    this.lex();
    var expr = this.parseUnaryExpression();
    switch (operator.type) {
      case TokenType.INC:
      case TokenType.DEC:
        // 11.4.4, 11.4.5;
        if (expr.type === "IdentifierExpression") {
          if (this.strict && isRestrictedWord(expr.identifier.name)) {
            throw this.createError(ErrorMessages.STRICT_LHS_PREFIX);
          }
        }

        if (!Parser.isLeftHandSide(expr)) {
          throw this.createError(ErrorMessages.INVALID_LHS_IN_ASSIGNMENT);
        }
        break;
      case TokenType.DELETE:
        if (expr.type === "IdentifierExpression" && this.strict) {
          throw this.createError(ErrorMessages.STRICT_DELETE);
        }
        break;
      default:
        break;
    }

    return this.markLocation(new PrefixExpression(operator.value, expr), startTokenIndex);
  };

  Parser.prototype.parsePostfixExpression = function () {
    var startTokenIndex = this.tokenIndex;

    var expr = this.parseLeftHandSideExpressionAllowCall();

    if (this.hasLineTerminatorBeforeNext) {
      return expr;
    }

    var operator = this.lookahead;
    if ((operator.type !== TokenType.INC) && (operator.type !== TokenType.DEC)) {
      return expr;
    }
    this.lex();
    // 11.3.1, 11.3.2;
    if (expr.type === "IdentifierExpression") {
      if (this.strict && isRestrictedWord(expr.identifier.name)) {
        throw this.createError(ErrorMessages.STRICT_LHS_POSTFIX);
      }
    }
    if (!Parser.isLeftHandSide(expr)) {
      throw this.createError(ErrorMessages.INVALID_LHS_IN_ASSIGNMENT);
    }
    return this.markLocation(new PostfixExpression(expr, operator.value), startTokenIndex);
  };

  Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
    var startTokenIndex = this.tokenIndex;
    var previousAllowIn = this.allowIn;
    this.allowIn = true;
    var expr = this.match(TokenType.NEW) ? this.parseNewExpression() : this.parsePrimaryExpression();

    while (true) {
      if (this.match(TokenType.LPAREN)) {
        expr = this.markLocation(new CallExpression(expr, this.parseArgumentList()), startTokenIndex);
      } else if (this.match(TokenType.LBRACK)) {
        expr = this.markLocation(new ComputedMemberExpression(expr, this.parseComputedMember()), startTokenIndex);
      } else if (this.match(TokenType.PERIOD)) {
        expr = this.markLocation(new StaticMemberExpression(expr, this.parseNonComputedMember()), startTokenIndex);
      } else {
        break;
      }
    }

    this.allowIn = previousAllowIn;

    return expr;
  };

  Parser.prototype.parseLeftHandSideExpression = function () {
    var startTokenIndex = this.tokenIndex;

    var expr = this.match(TokenType.NEW) ? this.parseNewExpression() : this.parsePrimaryExpression();

    while (this.match(TokenType.PERIOD) || this.match(TokenType.LBRACK)) {
      expr = this.markLocation(this.match(TokenType.LBRACK) ? new ComputedMemberExpression(expr, this.parseComputedMember()) : new StaticMemberExpression(expr, this.parseNonComputedMember()), startTokenIndex);
    }

    return expr;
  };

  Parser.prototype.parseNonComputedMember = function () {
    this.expect(TokenType.PERIOD);
    return this.parseNonComputedProperty();
  };

  Parser.prototype.parseComputedMember = function () {
    this.expect(TokenType.LBRACK);
    var expr = this.parseExpression();
    this.expect(TokenType.RBRACK);
    return expr;
  };

  Parser.prototype.parseNewExpression = function () {
    var startTokenIndex = this.tokenIndex;
    this.expect(TokenType.NEW);
    var callee = this.parseLeftHandSideExpression();
    return this.markLocation(new NewExpression(callee, this.match(TokenType.LPAREN) ? this.parseArgumentList() : []), startTokenIndex);
  };

  Parser.prototype.parsePrimaryExpression = function () {
    if (this.match(TokenType.LPAREN)) {
      return this.parseGroupExpression();
    }

    var startTokenIndex = this.tokenIndex;

    switch (this.lookahead.type.klass) {
      case TokenClass.Ident:
        return this.markLocation(new IdentifierExpression(this.parseIdentifier()), startTokenIndex);
      case TokenClass.StringLiteral:
        return this.parseStringLiteral();
      case TokenClass.NumericLiteral:
        return this.parseNumericLiteral();
      case TokenClass.Keyword:
        {
          if (this.match(TokenType.THIS)) {
            this.lex();
            return this.markLocation(new ThisExpression(), startTokenIndex);
          }
          if (this.match(TokenType.FUNCTION)) {
            return this.markLocation(this.parseFunction(true), startTokenIndex);
          }
          break;
        }
      case TokenClass.BooleanLiteral:
        {
          var token = this.lex();
          return this.markLocation(new LiteralBooleanExpression(token.type == TokenType.TRUE_LITERAL), startTokenIndex);
        }
      case TokenClass.NullLiteral:
        {
          this.lex();
          return this.markLocation(new LiteralNullExpression(), startTokenIndex);
        }
      default:
        if (this.match(TokenType.LBRACK)) {
          return this.parseArrayExpression();
        } else if (this.match(TokenType.LBRACE)) {
          return this.parseObjectExpression();
        } else if (this.match(TokenType.DIV) || this.match(TokenType.ASSIGN_DIV)) {
          this.skipComment();
          this.lookahead = this.scanRegExp();
          var token = this.lex();
          try {
            var lastSlash = token.value.lastIndexOf("/");
            RegExp(token.value.slice(1, lastSlash), token.value.slice(lastSlash + 1));
          } catch (unused) {
            throw this.createErrorWithToken(token, ErrorMessages.INVALID_REGULAR_EXPRESSION);
          }
          return this.markLocation(new LiteralRegExpExpression(token.value), startTokenIndex);
        }
    }

    throw this.createUnexpected(this.lex());
  };

  Parser.prototype.parseNumericLiteral = function () {
    var startTokenIndex = this.tokenIndex;
    if (this.strict && this.lookahead.octal) {
      throw this.createErrorWithToken(this.lookahead, ErrorMessages.STRICT_OCTAL_LITERAL);
    }
    var token2 = this.lex();
    return this.markLocation(new LiteralNumericExpression(token2._value), startTokenIndex);
  };

  Parser.prototype.parseStringLiteral = function () {
    var startTokenIndex = this.tokenIndex;
    if (this.strict && this.lookahead.octal) {
      throw this.createErrorWithToken(this.lookahead, ErrorMessages.STRICT_OCTAL_LITERAL);
    }
    var token2 = this.lex();
    return this.markLocation(new LiteralStringExpression(token2._value, token2.slice.text), startTokenIndex);
  };

  Parser.prototype.parseIdentifier = function () {
    var startTokenIndex = this.tokenIndex;
    return this.markLocation(new Identifier(this.lex().value), startTokenIndex);
  };

  Parser.prototype.parseArgumentList = function () {
    this.expect(TokenType.LPAREN);
    var args = this.parseArguments();
    this.expect(TokenType.RPAREN);
    return args;
  };

  Parser.prototype.parseArguments = function () {
    var result = [];
    while (true) {
      if (this.match(TokenType.RPAREN) || this.eof()) {
        return result;
      }
      var arg = this.parseAssignmentExpression();
      result.push(arg);
      if (!this.eat(TokenType.COMMA)) {
        break;
      }
    }
    return result;
  };

  Parser.prototype.parseNonComputedProperty = function () {
    var startTokenIndex = this.tokenIndex;

    var token = this.lex();

    if (!(token instanceof IdentifierLikeToken)) {
      throw this.createUnexpected(token);
    } else {
      return this.markLocation(new Identifier(token.value), startTokenIndex);
    }
  };

  Parser.prototype.parseGroupExpression = function () {
    this.expect(TokenType.LPAREN);
    var expr = this.parseExpression();
    this.expect(TokenType.RPAREN);
    return expr;
  };

  Parser.prototype.parseArrayExpression = function () {
    var startTokenIndex = this.tokenIndex;

    this.expect(TokenType.LBRACK);

    var elements = this.parseArrayExpressionElements();

    this.expect(TokenType.RBRACK);

    return this.markLocation(new ArrayExpression(elements), startTokenIndex);
  };

  Parser.prototype.parseArrayExpressionElements = function () {
    var result = [];
    while (true) {
      if (this.match(TokenType.RBRACK)) {
        return result;
      }
      var el = undefined;

      if (this.match(TokenType.COMMA)) {
        this.lex();
        el = null;
      } else {
        el = this.parseAssignmentExpression();
        if (!this.match(TokenType.RBRACK)) {
          this.expect(TokenType.COMMA);
        }
      }
      result.push(el);
    }
  };

  Parser.prototype.parseObjectExpression = function () {
    var startTokenIndex = this.tokenIndex;

    this.expect(TokenType.LBRACE);

    var propertyMap = Object.create(null);
    var properties = this.parseObjectExpressionItems(propertyMap);

    this.expect(TokenType.RBRACE);

    return this.markLocation(new ObjectExpression(properties), startTokenIndex);
  };

  Parser.prototype.parseObjectExpressionItems = function (propertyMap) {
    var result = [];
    while (!this.match(TokenType.RBRACE)) {
      result.push(this.parseObjectExpressionItem(propertyMap));
    }
    return result;
  };

  Parser.prototype.parseObjectExpressionItem = function (propertyMap) {
    var property = this.parseObjectProperty();
    var type = property.type;
    var key = "$" + property.name.value;
    var value = Object.prototype.hasOwnProperty.call(propertyMap, key) ? propertyMap[key] : 0;

    if (Object.prototype.hasOwnProperty.call(propertyMap, key)) {
      if ((value & INIT_MASK) !== 0) {
        if (this.strict && type === "DataProperty") {
          throw this.createError(ErrorMessages.STRICT_DUPLICATE_PROPERTY);
        } else if (type !== "DataProperty") {
          throw this.createError(ErrorMessages.ACCESSOR_DATA_PROPERTY);
        }
      } else {
        if (type === "DataProperty") {
          throw this.createError(ErrorMessages.ACCESSOR_DATA_PROPERTY);
        } else if ((value & GETTER_MASK) !== 0 && type == "Getter" || (value & SETTER_MASK) !== 0 && type == "Setter") {
          throw this.createError(ErrorMessages.ACCESSOR_GET_SET);
        }
      }
    }
    switch (type) {
      case "DataProperty":
        propertyMap[key] = value | INIT_MASK;
        break;
      case "Getter":
        propertyMap[key] = value | GETTER_MASK;
        break;
      case "Setter":
        propertyMap[key] = value | SETTER_MASK;
        break;
    }

    if (!this.match(TokenType.RBRACE)) {
      this.expect(TokenType.COMMA);
    }
    return property;
  };

  Parser.prototype.parseObjectPropertyKey = function () {
    var token = this.lookahead;

    // Note: This function is called only from parseObjectProperty(), where;
    // Eof and Punctuator tokens are already filtered out.

    if (token instanceof StringLiteralToken) {
      return new PropertyName("string", this.parseStringLiteral().value);
    }
    if (token instanceof NumericLiteralToken) {
      return new PropertyName("number", this.parseNumericLiteral().value);
    }
    if (token instanceof IdentifierLikeToken) {
      return new PropertyName("identifier", this.parseIdentifier().name);
    }

    throw this.createError(ErrorMessages.INVALID_PROPERTY_NAME);
  };

  Parser.prototype.parseObjectProperty = function () {
    var token = this.lookahead;
    var startTokenIndex = this.tokenIndex;

    if (token.type === TokenType.IDENTIFIER) {
      var key = this.parseObjectPropertyKey();
      var name = token.value;
      if (name.length === 3) {
        // Property Assignment: Getter and Setter.
        if ("get" === name && !this.match(TokenType.COLON)) {
          key = this.parseObjectPropertyKey();
          this.expect(TokenType.LPAREN);
          this.expect(TokenType.RPAREN);
          var _ref5 = this.parseFunctionBody();

          var _ref6 = _toArray(_ref5);

          var body = _ref6[0];
          var isStrict = _ref6[1];
          return this.markLocation(new Getter(key, body), startTokenIndex);
        } else if ("set" === name && !this.match(TokenType.COLON)) {
          key = this.parseObjectPropertyKey();
          this.expect(TokenType.LPAREN);
          token = this.lookahead;
          if (token.type !== TokenType.IDENTIFIER) {
            this.expect(TokenType.RPAREN);
            throw this.createErrorWithToken(token, ErrorMessages.UNEXPECTED_TOKEN, token.type.name);
          } else {
            var param = this.parseVariableIdentifier();
            this.expect(TokenType.RPAREN);
            var _ref7 = this.parseFunctionBody();

            var _ref8 = _toArray(_ref7);

            var body = _ref8[0];
            var isStrict = _ref8[1];
            if ((this.strict || isStrict) && isRestrictedWord(param.name)) {
              throw this.createError(ErrorMessages.STRICT_PARAM_NAME);
            }
            return this.markLocation(new Setter(key, param, body), startTokenIndex);
          }
        }
      }

      this.expect(TokenType.COLON);
      var value = this.parseAssignmentExpression();
      return this.markLocation(new DataProperty(key, value), startTokenIndex);
    }
    if (this.eof() || token.type.klass == TokenClass.Punctuator) {
      throw this.createUnexpected(token);
    } else {
      var key = this.parseObjectPropertyKey();
      this.expect(TokenType.COLON);
      var value = this.parseAssignmentExpression();
      return this.markLocation(new DataProperty(key, value), startTokenIndex);
    }
  };

  Parser.prototype.parseFunction = function (isExpression) {
    var startTokenIndex = this.tokenIndex;

    this.expect(TokenType.FUNCTION);

    var id = null;
    var message = null;
    var firstRestricted = null;
    if (!isExpression || !this.match(TokenType.LPAREN)) {
      var token = this.lookahead;
      id = this.parseVariableIdentifier();
      if (this.strict) {
        if (isRestrictedWord(id.name)) {
          throw this.createErrorWithToken(token, ErrorMessages.STRICT_FUNCTION_NAME);
        }
      } else {
        if (isRestrictedWord(id.name)) {
          firstRestricted = token;
          message = ErrorMessages.STRICT_FUNCTION_NAME;
        } else if (isStrictModeReservedWordES5(id.name)) {
          firstRestricted = token;
          message = ErrorMessages.STRICT_RESERVED_WORD;
        }
      }
    }
    var info = this.parseParams(firstRestricted);

    if (info.message != null) {
      message = info.message;
    }

    var previousStrict = this.strict;
    var _ref9 = this.parseFunctionBody();

    var _ref10 = _toArray(_ref9);

    var body = _ref10[0];
    var isStrict = _ref10[1];
    if (message != null) {
      if ((this.strict || isStrict) && info.firstRestricted != null) {
        throw this.createErrorWithToken(info.firstRestricted, message);
      }
      if ((this.strict || isStrict) && info.stricted != null) {
        throw this.createErrorWithToken(info.stricted, message);
      }
    }
    this.strict = previousStrict;
    return this.markLocation(new (isExpression ? FunctionExpression : FunctionDeclaration)(id, info.params, body), startTokenIndex);
  };

  Parser.prototype.parseParams = function (fr) {
    var info = { params: [] };
    info.firstRestricted = fr;
    this.expect(TokenType.LPAREN);

    if (!this.match(TokenType.RPAREN)) {
      var paramSet = Object.create(null);

      while (!this.eof()) {
        var token = this.lookahead;
        var param = this.parseVariableIdentifier();
        var key = "$" + param.name;
        if (this.strict) {
          if (token instanceof IdentifierLikeToken && isRestrictedWord(param.name)) {
            info.stricted = token;
            info.message = ErrorMessages.STRICT_PARAM_NAME;
          }
          if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
            info.stricted = token;
            info.message = ErrorMessages.STRICT_PARAM_DUPE;
          }
        } else if (info.firstRestricted == null) {
          if (token instanceof IdentifierLikeToken && isRestrictedWord(param.name)) {
            info.firstRestricted = token;
            info.message = ErrorMessages.STRICT_PARAM_NAME;
          } else if (STRICT_MODE_RESERVED_WORD.indexOf(param.name) !== -1) {
            info.firstRestricted = token;
            info.message = ErrorMessages.STRICT_RESERVED_WORD;
          } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {
            info.firstRestricted = token;
            info.message = ErrorMessages.STRICT_PARAM_DUPE;
          }
        }
        info.params.push(param);
        paramSet[key] = true;
        if (this.match(TokenType.RPAREN)) {
          break;
        }
        this.expect(TokenType.COMMA);
      }
    }

    this.expect(TokenType.RPAREN);
    return info;
  };

  return Parser;
})(Tokenizer);

exports.Parser = Parser;

},{"./errors":3,"./tokenizer":6,"./utils":7,"shift-ast":2}],6:[function(require,module,exports){
"use strict";

var _extends = function (child, parent) {
  child.prototype = Object.create(parent.prototype, {
    constructor: {
      value: child,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  child.__proto__ = parent;
};

var _classProps = function (child, staticProps, instanceProps) {
  if (staticProps) Object.defineProperties(child, staticProps);
  if (instanceProps) Object.defineProperties(child.prototype, instanceProps);
};

var getHexValue = require("./utils").getHexValue;
var isLineTerminator = require("./utils").isLineTerminator;
var isWhitespace = require("./utils").isWhitespace;
var isIdentifierStart = require("./utils").isIdentifierStart;
var isIdentifierPart = require("./utils").isIdentifierPart;
var isDecimalDigit = require("./utils").isDecimalDigit;
var ErrorMessages = require("./errors").ErrorMessages;
var TokenClass = exports.TokenClass = {
  BooleanLiteral: { name: "Boolean" },
  Eof: { name: "<End>" },
  Ident: { name: "Identifier" },
  Keyword: { name: "Keyword" },
  NullLiteral: { name: "Null" },
  NumericLiteral: { name: "Numeric" },
  Punctuator: { name: "Punctuator" },
  StringLiteral: { name: "String" },
  RegularExpression: { name: "RegularExpression" },
  LineComment: { name: "Line" },
  BlockComment: { name: "Block" },
  Illegal: { name: "Illegal" }
};

var TokenType = exports.TokenType = {
  EOS: { klass: TokenClass.Eof, name: "EOS" },
  LPAREN: { klass: TokenClass.Punctuator, name: "(" },
  RPAREN: { klass: TokenClass.Punctuator, name: ")" },
  LBRACK: { klass: TokenClass.Punctuator, name: "[" },
  RBRACK: { klass: TokenClass.Punctuator, name: "]" },
  LBRACE: { klass: TokenClass.Punctuator, name: "{" },
  RBRACE: { klass: TokenClass.Punctuator, name: "}" },
  COLON: { klass: TokenClass.Punctuator, name: ":" },
  SEMICOLON: { klass: TokenClass.Punctuator, name: ";" },
  PERIOD: { klass: TokenClass.Punctuator, name: "." },
  CONDITIONAL: { klass: TokenClass.Punctuator, name: "?" },
  INC: { klass: TokenClass.Punctuator, name: "++" },
  DEC: { klass: TokenClass.Punctuator, name: "--" },
  ASSIGN: { klass: TokenClass.Punctuator, name: "=" },
  ASSIGN_BIT_OR: { klass: TokenClass.Punctuator, name: "|=" },
  ASSIGN_BIT_XOR: { klass: TokenClass.Punctuator, name: "^=" },
  ASSIGN_BIT_AND: { klass: TokenClass.Punctuator, name: "&=" },
  ASSIGN_SHL: { klass: TokenClass.Punctuator, name: "<<=" },
  ASSIGN_SHR: { klass: TokenClass.Punctuator, name: ">>=" },
  ASSIGN_SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>=" },
  ASSIGN_ADD: { klass: TokenClass.Punctuator, name: "+=" },
  ASSIGN_SUB: { klass: TokenClass.Punctuator, name: "-=" },
  ASSIGN_MUL: { klass: TokenClass.Punctuator, name: "*=" },
  ASSIGN_DIV: { klass: TokenClass.Punctuator, name: "/=" },
  ASSIGN_MOD: { klass: TokenClass.Punctuator, name: "%=" },
  COMMA: { klass: TokenClass.Punctuator, name: "," },
  OR: { klass: TokenClass.Punctuator, name: "||" },
  AND: { klass: TokenClass.Punctuator, name: "&&" },
  BIT_OR: { klass: TokenClass.Punctuator, name: "|" },
  BIT_XOR: { klass: TokenClass.Punctuator, name: "^" },
  BIT_AND: { klass: TokenClass.Punctuator, name: "&" },
  SHL: { klass: TokenClass.Punctuator, name: "<<" },
  SHR: { klass: TokenClass.Punctuator, name: ">>" },
  SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: ">>>" },
  ADD: { klass: TokenClass.Punctuator, name: "+" },
  SUB: { klass: TokenClass.Punctuator, name: "-" },
  MUL: { klass: TokenClass.Punctuator, name: "*" },
  DIV: { klass: TokenClass.Punctuator, name: "/" },
  MOD: { klass: TokenClass.Punctuator, name: "%" },
  EQ: { klass: TokenClass.Punctuator, name: "==" },
  NE: { klass: TokenClass.Punctuator, name: "!=" },
  EQ_STRICT: { klass: TokenClass.Punctuator, name: "===" },
  NE_STRICT: { klass: TokenClass.Punctuator, name: "!==" },
  LT: { klass: TokenClass.Punctuator, name: "<" },
  GT: { klass: TokenClass.Punctuator, name: ">" },
  LTE: { klass: TokenClass.Punctuator, name: "<=" },
  GTE: { klass: TokenClass.Punctuator, name: ">=" },
  INSTANCEOF: { klass: TokenClass.Keyword, name: "instanceof" },
  IN: { klass: TokenClass.Keyword, name: "in" },
  NOT: { klass: TokenClass.Punctuator, name: "!" },
  BIT_NOT: { klass: TokenClass.Punctuator, name: "~" },
  DELETE: { klass: TokenClass.Keyword, name: "delete" },
  TYPEOF: { klass: TokenClass.Keyword, name: "typeof" },
  VOID: { klass: TokenClass.Keyword, name: "void" },
  BREAK: { klass: TokenClass.Keyword, name: "break" },
  CASE: { klass: TokenClass.Keyword, name: "case" },
  CATCH: { klass: TokenClass.Keyword, name: "catch" },
  CONTINUE: { klass: TokenClass.Keyword, name: "continue" },
  DEBUGGER: { klass: TokenClass.Keyword, name: "debugger" },
  DEFAULT: { klass: TokenClass.Keyword, name: "default" },
  DO: { klass: TokenClass.Keyword, name: "do" },
  ELSE: { klass: TokenClass.Keyword, name: "else" },
  FINALLY: { klass: TokenClass.Keyword, name: "finally" },
  FOR: { klass: TokenClass.Keyword, name: "for" },
  FUNCTION: { klass: TokenClass.Keyword, name: "function" },
  IF: { klass: TokenClass.Keyword, name: "if" },
  NEW: { klass: TokenClass.Keyword, name: "new" },
  RETURN: { klass: TokenClass.Keyword, name: "return" },
  SWITCH: { klass: TokenClass.Keyword, name: "switch" },
  THIS: { klass: TokenClass.Keyword, name: "this" },
  THROW: { klass: TokenClass.Keyword, name: "throw" },
  TRY: { klass: TokenClass.Keyword, name: "try" },
  VAR: { klass: TokenClass.Keyword, name: "var" },
  WHILE: { klass: TokenClass.Keyword, name: "while" },
  WITH: { klass: TokenClass.Keyword, name: "with" },
  NULL_LITERAL: { klass: TokenClass.NullLiteral, name: "null" },
  TRUE_LITERAL: { klass: TokenClass.BooleanLiteral, name: "true" },
  FALSE_LITERAL: { klass: TokenClass.BooleanLiteral, name: "false" },
  NUMBER: { klass: TokenClass.NumericLiteral, name: "" },
  STRING: { klass: TokenClass.StringLiteral, name: "" },
  REGEXP: { klass: TokenClass.RegularExpression, name: "" },
  IDENTIFIER: { klass: TokenClass.Ident, name: "" },
  FUTURE_RESERVED_WORD: { klass: TokenClass.Keyword, name: "" },
  FUTURE_STRICT_RESERVED_WORD: { klass: TokenClass.Keyword, name: "" },
  CONST: { klass: TokenClass.Keyword, name: "const" },
  LET: { klass: TokenClass.Keyword, name: "let" },
  ILLEGAL: { klass: TokenClass.Illegal, name: "" }
};

var TT = TokenType;
var I = TT.ILLEGAL;
var F = false;
var T = true;

var ONE_CHAR_PUNCTUATOR = [I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.NOT, I, I, I, TT.MOD, TT.BIT_AND, I, TT.LPAREN, TT.RPAREN, TT.MUL, TT.ADD, TT.COMMA, TT.SUB, TT.PERIOD, TT.DIV, I, I, I, I, I, I, I, I, I, I, TT.COLON, TT.SEMICOLON, TT.LT, TT.ASSIGN, TT.GT, TT.CONDITIONAL, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACK, I, TT.RBRACK, TT.BIT_XOR, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACE, TT.BIT_OR, TT.RBRACE, TT.BIT_NOT];

var PUNCTUATOR_START = [F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, F, F, T, T, F, T, T, T, T, T, T, F, T, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, F];

var IDENTIFIER_START = [F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, T, F, F, T, F, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, T, F, F, F, F, F];

var Token = (function () {
  var Token = function Token(type, slice, octal) {
    this.type = type;
    this.slice = slice;
    this.octal = octal;
  };

  _classProps(Token, null, {
    value: {
      get: function () {}
    }
  });

  return Token;
})();

exports.Token = Token;
var IdentifierLikeToken = (function (Token) {
  var IdentifierLikeToken = function IdentifierLikeToken(type, slice) {
    Token.call(this, type, slice, false);
  };

  _extends(IdentifierLikeToken, Token);

  _classProps(IdentifierLikeToken, null, {
    value: {
      get: function () {
        return this.slice.text;
      }
    }
  });

  return IdentifierLikeToken;
})(Token);

exports.IdentifierLikeToken = IdentifierLikeToken;
var IdentifierToken = (function (IdentifierLikeToken) {
  var IdentifierToken = function IdentifierToken(slice) {
    IdentifierLikeToken.call(this, TokenType.IDENTIFIER, slice);
  };

  _extends(IdentifierToken, IdentifierLikeToken);

  return IdentifierToken;
})(IdentifierLikeToken);

exports.IdentifierToken = IdentifierToken;
var NullLiteralToken = (function (IdentifierLikeToken) {
  var NullLiteralToken = function NullLiteralToken(slice) {
    IdentifierLikeToken.call(this, TokenType.NULL_LITERAL, slice);
  };

  _extends(NullLiteralToken, IdentifierLikeToken);

  return NullLiteralToken;
})(IdentifierLikeToken);

exports.NullLiteralToken = NullLiteralToken;
var TrueLiteralToken = (function (IdentifierLikeToken) {
  var TrueLiteralToken = function TrueLiteralToken(slice) {
    IdentifierLikeToken.call(this, TokenType.TRUE_LITERAL, slice);
  };

  _extends(TrueLiteralToken, IdentifierLikeToken);

  return TrueLiteralToken;
})(IdentifierLikeToken);

exports.TrueLiteralToken = TrueLiteralToken;
var FalseLiteralToken = (function (IdentifierLikeToken) {
  var FalseLiteralToken = function FalseLiteralToken(slice) {
    IdentifierLikeToken.call(this, TokenType.FALSE_LITERAL, slice);
  };

  _extends(FalseLiteralToken, IdentifierLikeToken);

  return FalseLiteralToken;
})(IdentifierLikeToken);

exports.FalseLiteralToken = FalseLiteralToken;
var KeywordToken = (function (IdentifierLikeToken) {
  var KeywordToken = function KeywordToken(type, slice) {
    IdentifierLikeToken.call(this, type, slice);
  };

  _extends(KeywordToken, IdentifierLikeToken);

  return KeywordToken;
})(IdentifierLikeToken);

exports.KeywordToken = KeywordToken;
var PunctuatorToken = (function (Token) {
  var PunctuatorToken = function PunctuatorToken(type, slice) {
    Token.call(this, type, slice, false);
  };

  _extends(PunctuatorToken, Token);

  _classProps(PunctuatorToken, null, {
    value: {
      get: function () {
        return this.type.name;
      }
    }
  });

  return PunctuatorToken;
})(Token);

exports.PunctuatorToken = PunctuatorToken;
var RegularExpressionLiteralToken = (function (Token) {
  var RegularExpressionLiteralToken = function RegularExpressionLiteralToken(slice, value) {
    Token.call(this, TokenType.REGEXP, slice, false);
    this._value = value;
  };

  _extends(RegularExpressionLiteralToken, Token);

  _classProps(RegularExpressionLiteralToken, null, {
    value: {
      get: function () {
        return this._value;
      }
    }
  });

  return RegularExpressionLiteralToken;
})(Token);

exports.RegularExpressionLiteralToken = RegularExpressionLiteralToken;
var NumericLiteralToken = (function (Token) {
  var NumericLiteralToken = function NumericLiteralToken(slice, value, octal) {
    var _this = this;
    if (value === undefined) value = +slice.text;
    if (octal === undefined) octal = false;
    return (function () {
      Token.call(_this, TokenType.NUMBER, slice, octal);
      _this._value = value;
    })();
  };

  _extends(NumericLiteralToken, Token);

  _classProps(NumericLiteralToken, null, {
    value: {
      get: function () {
        return this._value.toString();
      }
    }
  });

  return NumericLiteralToken;
})(Token);

exports.NumericLiteralToken = NumericLiteralToken;
var StringLiteralToken = (function (Token) {
  var StringLiteralToken = function StringLiteralToken(slice, value, octal) {
    Token.call(this, TokenType.STRING, slice, octal);
    this._value = value;
  };

  _extends(StringLiteralToken, Token);

  _classProps(StringLiteralToken, null, {
    value: {
      get: function () {
        return this._value;
      }
    }
  });

  return StringLiteralToken;
})(Token);

exports.StringLiteralToken = StringLiteralToken;
var EOFToken = (function (Token) {
  var EOFToken = function EOFToken(slice) {
    Token.call(this, TokenType.EOS, slice, false);
  };

  _extends(EOFToken, Token);

  _classProps(EOFToken, null, {
    value: {
      get: function () {
        return "";
      }
    }
  });

  return EOFToken;
})(Token);

exports.EOFToken = EOFToken;
var JsError = function JsError(index, line, column, msg) {
  this.index = index;
  this.line = line;
  this.column = column;
  this.description = msg;
  this.message = "[" + line + ":" + column + "]: " + msg;
};

exports.JsError = JsError;
var Tokenizer = (function () {
  var Tokenizer = function Tokenizer(source) {
    this.source = source;
    this.index = 0;
    this.lineStarts = [0];
    this.lookaheadStart = 0;
    this.lookahead = this.advance();
    this.lookaheadEnd = this.index;
    this.index = 0;
    this.strict = false;
    this.hasLineTerminatorBeforeNext = false;
    this.prevToken = null;
    this.tokenIndex = 0;
    this.lineStarts = [0];
  };

  Tokenizer.prototype.trackBackLineNumber = function (position) {
    for (var line = this.lineStarts.length - 1; line >= 0; line--) {
      if ((position >= this.getLineStart(line))) {
        return line;
      }
    }
    return 0;
  };

  Tokenizer.prototype.createILLEGAL = function () {
    return this.createError(ErrorMessages.UNEXPECTED_ILLEGAL_TOKEN);
  };

  Tokenizer.prototype.createUnexpected = function (token) {
    switch (token.type.klass) {
      case TokenClass.Eof:
        return this.createError(ErrorMessages.UNEXPECTED_EOS);
      case TokenClass.NumericLiteral:
        return this.createError(ErrorMessages.UNEXPECTED_NUMBER);
      case TokenClass.StringLiteral:
        return this.createError(ErrorMessages.UNEXPECTED_STRING);
      case TokenClass.Ident:
        return this.createError(ErrorMessages.UNEXPECTED_IDENTIFIER);
      case TokenClass.Keyword:
        if ((token.type === TokenType.FUTURE_RESERVED_WORD)) {
          return this.createError(ErrorMessages.UNEXPECTED_RESERVED_WORD);
        }
        if ((token.type === TokenType.FUTURE_STRICT_RESERVED_WORD)) {
          return this.createError(ErrorMessages.STRICT_RESERVED_WORD);
        }
        return this.createError(ErrorMessages.UNEXPECTED_TOKEN, token.slice.text);
      case TokenClass.Punctuator:
        return this.createError(ErrorMessages.UNEXPECTED_TOKEN, token.type.name);
      default:
        break;
    }
    return this.createError(ErrorMessages.UNEXPECTED_TOKEN, token.value || token.type.name);
  };

  Tokenizer.prototype.createError = function (message, arg) {
    var msg = message.replace(/{(\d+)}/g, function () {
      return arg;
    });
    var index = this.index;
    var line = this.trackBackLineNumber(index);
    return new JsError(index, line + 1, index - this.getLineStart(line) + 1, msg);
  };

  Tokenizer.prototype.createErrorWithToken = function (token, message, arg) {
    var msg = message.replace(/{(\d+)}/g, function () {
      return arg;
    });
    var index = token.slice.start;
    var line = this.trackBackLineNumber(index);
    return new JsError(index, line + 1, index - this.getLineStart(line) + 1, msg);
  };

  Tokenizer.prototype.getLineStart = function (line) {
    return this.lineStarts[line];
  };

  Tokenizer.cse2 = function (id, ch1, ch2) {
    return id.charAt(1) === ch1 && id.charAt(2) === ch2;
  };

  Tokenizer.cse3 = function (id, ch1, ch2, ch3) {
    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3;
  };

  Tokenizer.cse4 = function (id, ch1, ch2, ch3, ch4) {
    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4;
  };

  Tokenizer.cse5 = function (id, ch1, ch2, ch3, ch4, ch5) {
    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5;
  };

  Tokenizer.cse6 = function (id, ch1, ch2, ch3, ch4, ch5, ch6) {
    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6;
  };

  Tokenizer.cse7 = function (id, ch1, ch2, ch3, ch4, ch5, ch6, ch7) {
    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6 && id.charAt(7) === ch7;
  };

  Tokenizer.getKeyword = function (id, strict) {
    // "const" is specialized as Keyword in V8.
    // "yield" and "let" are for compatibility with SpiderMonkey and ES.next.
    // Some others are from future reserved words.

    if (id.length === 1 || id.length > 10) {
      return TokenType.ILLEGAL;
    }
    switch (id.length) {
      case 2:
        switch (id.charAt(0)) {
          case "i":
            switch (id.charAt(1)) {
              case "f":
                return TokenType.IF;
              case "n":
                return TokenType.IN;
              default:
                break;
            }
            break;
          case "d":
            if (id.charAt(1) === "o") {
              return TokenType.DO;
            }
            break;
          default:
            break;
        }
        break;
      case 3:
        switch (id.charAt(0)) {
          case "v":
            if (Tokenizer.cse2(id, "a", "r")) {
              return TokenType.VAR;
            }
            break;
          case "f":
            if (Tokenizer.cse2(id, "o", "r")) {
              return TokenType.FOR;
            }
            break;
          case "n":
            if (Tokenizer.cse2(id, "e", "w")) {
              return TokenType.NEW;
            }
            break;
          case "t":
            if (Tokenizer.cse2(id, "r", "y")) {
              return TokenType.TRY;
            }
            break;
          case "l":
            if (Tokenizer.cse2(id, "e", "t")) {
              return strict ? TokenType.FUTURE_STRICT_RESERVED_WORD : TokenType.LET;
            }
            break;
          default:
            break;
        }
        break;
      case 4:
        switch (id.charAt(0)) {
          case "t":
            if (Tokenizer.cse3(id, "h", "i", "s")) {
              return TokenType.THIS;
            }
            break;
          case "e":
            if (Tokenizer.cse3(id, "l", "s", "e")) {
              return TokenType.ELSE;
            } else if (Tokenizer.cse3(id, "n", "u", "m")) {
              return TokenType.FUTURE_RESERVED_WORD;
            }
            break;
          case "c":
            if (Tokenizer.cse3(id, "a", "s", "e")) {
              return TokenType.CASE;
            }
            break;
          case "v":
            if (Tokenizer.cse3(id, "o", "i", "d")) {
              return TokenType.VOID;
            }
            break;
          case "w":
            if (Tokenizer.cse3(id, "i", "t", "h")) {
              return TokenType.WITH;
            }
            break;
          default:
            break;
        }
        break;
      case 5:
        switch (id.charAt(0)) {
          case "w": // WHILE
            if (Tokenizer.cse4(id, "h", "i", "l", "e")) {
              return TokenType.WHILE;
            }
            break;
          case "b": // BREAK
            if (Tokenizer.cse4(id, "r", "e", "a", "k")) {
              return TokenType.BREAK;
            }
            break;
          case "c": // CATCH
            if (Tokenizer.cse4(id, "a", "t", "c", "h")) {
              return TokenType.CATCH;
            } else if (Tokenizer.cse4(id, "o", "n", "s", "t")) {
              return TokenType.CONST;
            } else if (Tokenizer.cse4(id, "l", "a", "s", "s")) {
              return TokenType.FUTURE_RESERVED_WORD;
            }
            break;
          case "t": // THROW
            if (Tokenizer.cse4(id, "h", "r", "o", "w")) {
              return TokenType.THROW;
            }
            break;
          case "y": // YIELD
            if (Tokenizer.cse4(id, "i", "e", "l", "d")) {
              return strict ? TokenType.FUTURE_STRICT_RESERVED_WORD : TokenType.ILLEGAL;
            }
            break;
          case "s": // SUPER
            if (Tokenizer.cse4(id, "u", "p", "e", "r")) {
              return TokenType.FUTURE_RESERVED_WORD;
            }
            break;
          default:
            break;
        }
        break;
      case 6:
        switch (id.charAt(0)) {
          case "r":
            if (Tokenizer.cse5(id, "e", "t", "u", "r", "n")) {
              return TokenType.RETURN;
            }
            break;
          case "t":
            if (Tokenizer.cse5(id, "y", "p", "e", "o", "f")) {
              return TokenType.TYPEOF;
            }
            break;
          case "d":
            if (Tokenizer.cse5(id, "e", "l", "e", "t", "e")) {
              return TokenType.DELETE;
            }
            break;
          case "s":
            if (Tokenizer.cse5(id, "w", "i", "t", "c", "h")) {
              return TokenType.SWITCH;
            } else if (strict && Tokenizer.cse5(id, "t", "a", "t", "i", "c")) {
              return TokenType.FUTURE_STRICT_RESERVED_WORD;
            }
            break;
          case "e":
            if (Tokenizer.cse5(id, "x", "p", "o", "r", "t")) {
              return TokenType.FUTURE_RESERVED_WORD;
            }
            break;
          case "i":
            if (Tokenizer.cse5(id, "m", "p", "o", "r", "t")) {
              return TokenType.FUTURE_RESERVED_WORD;
            }
            break;
          case "p":
            if (strict && Tokenizer.cse5(id, "u", "b", "l", "i", "c")) {
              return TokenType.FUTURE_STRICT_RESERVED_WORD;
            }
            break;
          default:
            break;
        }
        break;
      case 7:
        switch (id.charAt(0)) {
          case "d": // default
            if (Tokenizer.cse6(id, "e", "f", "a", "u", "l", "t")) {
              return TokenType.DEFAULT;
            }
            break;
          case "f": // finally
            if (Tokenizer.cse6(id, "i", "n", "a", "l", "l", "y")) {
              return TokenType.FINALLY;
            }
            break;
          case "e": // extends
            if (Tokenizer.cse6(id, "x", "t", "e", "n", "d", "s")) {
              return TokenType.FUTURE_RESERVED_WORD;
            }
            break;
          case "p":
            if (strict) {
              var s = id;
              if ("private" === s || "package" === s) {
                return TokenType.FUTURE_STRICT_RESERVED_WORD;
              }
            }
            break;
          default:
            break;
        }
        break;
      case 8:
        switch (id.charAt(0)) {
          case "f":
            if (Tokenizer.cse7(id, "u", "n", "c", "t", "i", "o", "n")) {
              return TokenType.FUNCTION;
            }
            break;
          case "c":
            if (Tokenizer.cse7(id, "o", "n", "t", "i", "n", "u", "e")) {
              return TokenType.CONTINUE;
            }
            break;
          case "d":
            if (Tokenizer.cse7(id, "e", "b", "u", "g", "g", "e", "r")) {
              return TokenType.DEBUGGER;
            }
            break;
          default:
            break;
        }
        break;
      case 9:
        if (strict && (id.charAt(0) === "p" || id.charAt(0) === "i")) {
          var s = id;
          if ("protected" === s || "interface" === s) {
            return TokenType.FUTURE_STRICT_RESERVED_WORD;
          }
        }
        break;
      case 10:
        {
          var s = id;
          if ("instanceof" === s) {
            return TokenType.INSTANCEOF;
          } else if (strict && "implements" === s) {
            return TokenType.FUTURE_STRICT_RESERVED_WORD;
          }
        }
        break;
      default:
        break;
    }
    return TokenType.ILLEGAL;
  };

  Tokenizer.prototype.skipSingleLineComment = function (offset) {
    this.index += offset;
    while (this.index < this.source.length) {
      /**
       * @type {Number}
       */
      var chCode = this.source.charCodeAt(this.index);
      this.index++;
      if (isLineTerminator(chCode)) {
        this.hasLineTerminatorBeforeNext = true;
        if (chCode === 13 /* "\r" */ && this.index < this.source.length && this.source.charCodeAt(this.index) === 10 /*"\n" */) {
          this.index++;
        }
        this.lineStarts.push(this.index);
        return;
      }
    }
  };

  Tokenizer.prototype.skipMultiLineComment = function () {
    this.index += 2;
    var length = this.source.length;
    var i = this.index;
    while (i < length) {
      var chCode = this.source.charCodeAt(i);
      if (chCode < 128) {
        switch (chCode) {
          case 42: // "*"
            // Block comment ends with "*/'.
            if (i + 1 < length && this.source.charAt(i + 1) === "/") {
              this.index = i + 2;
              return;
            }
            i++;
            break;
          case 10: // "\n"
            this.hasLineTerminatorBeforeNext = true;
            i++;
            this.lineStarts.push(this.index);
            break;
          case 12: // "\r":
            this.hasLineTerminatorBeforeNext = true;
            if (i < length - 1 && this.source.charAt(i + 1) === "\n") {
              i++;
            }
            i++;
            this.lineStarts.push(this.index);
            break;
          default:
            i++;
        }
      } else if (chCode === 8232 || chCode === 8233) {
        i++;
        this.lineStarts.push(this.index);
      } else {
        i++;
      }
    }
    this.index = i;
    throw this.createILLEGAL();
  };

  Tokenizer.prototype.skipComment = function () {
    var isLineStart = this.index === 0;
    var length = this.source.length;

    while (this.index < length) {
      var chCode = this.source.charCodeAt(this.index);
      if (isWhitespace(chCode)) {
        this.index++;
      } else if (isLineTerminator(chCode)) {
        this.hasLineTerminatorBeforeNext = true;
        this.index++;
        if (chCode === 13 /* "\r" */ && this.index < length && this.source.charAt(this.index) === "\n") {
          this.index++;
        }
        this.lineStarts.push(this.index);
        isLineStart = true;
      } else if (chCode === 47 /* "/" */) {
        if (this.index + 1 >= length) {
          break;
        }
        chCode = this.source.charCodeAt(this.index + 1);
        if (chCode === 47 /* "/" */) {
          this.skipSingleLineComment(2);
          isLineStart = true;
        } else if (chCode === 42 /* "*" */) {
          this.skipMultiLineComment();
        } else {
          break;
        }
      } else if (isLineStart && chCode === 45 /* "-" */) {
        if (this.index + 2 >= length) {
          break;
        }
        // U+003E is ">'
        if ((this.source.charAt(this.index + 1) === "-") && (this.source.charAt(this.index + 2) === ">")) {
          // "-->" is a single-line comment
          this.skipSingleLineComment(3);
        } else {
          break;
        }
      } else if (chCode === 60 /* "<" */) {
        if (this.index + 4 <= length && this.source.charAt(this.index + 1) === "!" && this.source.charAt(this.index + 2) === "-" && this.source.charAt(this.index + 3) === "-") {
          this.skipSingleLineComment(4);
        } else {
          break;
        }
      } else {
        break;
      }
    }
  };

  Tokenizer.prototype.scanHexEscape4 = function () {
    if (this.index + 4 > this.source.length) {
      return -1;
    }
    var r1 = getHexValue(this.source.charAt(this.index));
    if (r1 === -1) {
      return -1;
    }
    var r2 = getHexValue(this.source.charAt(this.index + 1));
    if (r2 === -1) {
      return -1;
    }
    var r3 = getHexValue(this.source.charAt(this.index + 2));
    if (r3 === -1) {
      return -1;
    }
    var r4 = getHexValue(this.source.charAt(this.index + 3));
    if (r4 === -1) {
      return -1;
    }
    this.index += 4;
    return r1 << 12 | r2 << 8 | r3 << 4 | r4;
  };

  Tokenizer.prototype.scanHexEscape2 = function () {
    if (this.index + 2 > this.source.length) {
      return -1;
    }
    var r1 = getHexValue(this.source.charAt(this.index));
    if (r1 === -1) {
      return -1;
    }
    var r2 = getHexValue(this.source.charAt(this.index + 1));
    if (r2 === -1) {
      return -1;
    }
    this.index += 2;
    return r1 << 4 | r2;
  };

  Tokenizer.prototype.getEscapedIdentifier = function () {
    var ch = this.source.charAt(this.index);
    this.index++;
    if (this.index >= this.source.length) {
      throw this.createILLEGAL();
    }

    var id = "";

    if (ch === "\\") {
      if (this.source.charAt(this.index) !== "u") {
        throw this.createILLEGAL();
      }
      this.index++;
      if (this.index >= this.source.length) {
        throw this.createILLEGAL();
      }
      var ich = this.scanHexEscape4();
      if (ich < 0 || ich === 92 /* "\\" */ || !isIdentifierStart(ich)) {
        throw this.createILLEGAL();
      }
      ch = String.fromCharCode(ich);
    }
    id += ch;

    while (this.index < this.source.length) {
      ch = this.source.charAt(this.index);
      if (!isIdentifierPart(ch.charCodeAt(0)) && ch !== "\\") {
        break;
      }
      this.index++;
      if (ch === "\\") {
        if (this.index >= this.source.length) {
          throw this.createILLEGAL();
        }
        if (this.source.charAt(this.index) !== "u") {
          throw this.createILLEGAL();
        }
        this.index++;
        if (this.index >= this.source.length) {
          throw this.createILLEGAL();
        }
        var ich = this.scanHexEscape4();
        if (ich < 0 || ich === 92 /* "\\" */ || !isIdentifierPart(ich)) {
          throw this.createILLEGAL();
        }
        ch = String.fromCharCode(ich);
      }
      id += ch;
    }

    return id;
  };

  Tokenizer.prototype.getIdentifier = function () {
    var start = this.index;
    this.index++;
    var l = this.source.length;
    var i = this.index;
    while (i < l) {
      var ch = this.source.charAt(i);
      if (ch === "\\") {
        // Go back and try the hard one.
        this.index = start;
        return this.getEscapedIdentifier();
      } else if (isIdentifierPart(ch.charCodeAt(0))) {
        i++;
      } else {
        break;
      }
    }
    this.index = i;
    return this.source.slice(start, this.index);
  };

  Tokenizer.prototype.scanIdentifier = function () {
    var start = this.index;

    // Backslash (U+005C) starts an escaped character.
    var id = this.source.charAt(this.index) === "\\" ? this.getEscapedIdentifier() : this.getIdentifier();

    // There is no keyword or literal with only one character.
    // Thus, it must be an identifier.
    var slice = { text: id, start: start, end: this.index };
    if ((id.length === 1)) {
      return new IdentifierToken(slice);
    }

    var subType = Tokenizer.getKeyword(id, this.strict);
    if (subType !== TokenType.ILLEGAL) {
      return new KeywordToken(subType, slice);
    }

    if (id.length === 4) {
      if ("null" === id) {
        return new NullLiteralToken(slice);
      } else if ("true" === id) {
        return new TrueLiteralToken(slice);
      }
    }

    if (id.length === 5 && "false" === id) {
      return new FalseLiteralToken(slice);
    }

    return new IdentifierToken(slice);
  };

  Tokenizer.prototype.getSlice = function (start) {
    return { text: this.source.slice(start, this.index), start: start, end: this.index };
  };

  Tokenizer.prototype.scanPunctuatorHelper = function () {
    var ch1 = this.source.charAt(this.index);

    switch (ch1) {
      // Check for most common single-character punctuators.
      case ".":
        return TokenType.PERIOD;
      case "(":
        return TokenType.LPAREN;
      case ")":
      case ";":
      case ",":
        return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
      case "{":
        return TokenType.LBRACE;
      case "}":
      case "[":
      case "]":
      case ":":
      case "?":
      case "~":
        return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
      default:
        // "=" (U+003D) marks an assignment or comparison operator.
        if (this.index + 1 < this.source.length && this.source.charAt(this.index + 1) === "=") {
          switch (ch1) {
            case "=":
              if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
                return TokenType.EQ_STRICT;
              }
              return TokenType.EQ;
            case "!":
              if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === "=") {
                return TokenType.NE_STRICT;
              }
              return TokenType.NE;
            case "|":
              return TokenType.ASSIGN_BIT_OR;
            case "+":
              return TokenType.ASSIGN_ADD;
            case "-":
              return TokenType.ASSIGN_SUB;
            case "*":
              return TokenType.ASSIGN_MUL;
            case "<":
              return TokenType.LTE;
            case ">":
              return TokenType.GTE;
            case "/":
              return TokenType.ASSIGN_DIV;
            case "%":
              return TokenType.ASSIGN_MOD;
            case "^":
              return TokenType.ASSIGN_BIT_XOR;
            case "&":
              return TokenType.ASSIGN_BIT_AND;
            default:
              break; //failed
          }
        }
    }

    if (this.index + 1 < this.source.length) {
      var ch2 = this.source.charAt(this.index + 1);
      if (ch1 === ch2) {
        if (this.index + 2 < this.source.length) {
          var ch3 = this.source.charAt(this.index + 2);
          if (ch1 === ">" && ch3 === ">") {
            // 4-character punctuator: >>>=
            if (this.index + 3 < this.source.length && this.source.charAt(this.index + 3) === "=") {
              return TokenType.ASSIGN_SHR_UNSIGNED;
            }
            return TokenType.SHR_UNSIGNED;
          }

          if (ch1 === "<" && ch3 === "=") {
            return TokenType.ASSIGN_SHL;
          }

          if (ch1 === ">" && ch3 === "=") {
            return TokenType.ASSIGN_SHR;
          }
        }
        // Other 2-character punctuators: ++ -- << >> && ||
        switch (ch1) {
          case "+":
            return TokenType.INC;
          case "-":
            return TokenType.DEC;
          case "<":
            return TokenType.SHL;
          case ">":
            return TokenType.SHR;
          case "&":
            return TokenType.AND;
          case "|":
            return TokenType.OR;
          default:
            break; //failed
        }
      }
    }

    return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];
  };

  Tokenizer.prototype.scanPunctuator = function () {
    var start = this.index;
    var subType = this.scanPunctuatorHelper();
    this.index += subType.name.length;
    return new PunctuatorToken(subType, this.getSlice(start));
  };

  Tokenizer.prototype.scanHexLiteral = function (start) {
    var i = this.index;
    while (i < this.source.length) {
      var ch = this.source.charAt(i);
      var hex = getHexValue(ch);
      if (hex === -1) {
        break;
      }
      i++;
    }

    if (this.index === i) {
      throw this.createILLEGAL();
    }

    if (i < this.source.length && isIdentifierStart(this.source.charCodeAt(i))) {
      throw this.createILLEGAL();
    }

    this.index = i;

    var slice = this.getSlice(start);
    return new NumericLiteralToken(slice, parseInt(slice.text.substr(2), 16));
  };

  Tokenizer.prototype.scanOctalLiteral = function (start) {
    while (this.index < this.source.length) {
      var ch = this.source.charAt(this.index);
      if (!("0" <= ch && ch <= "7")) {
        break;
      }
      this.index++;
    }

    if (this.index < this.source.length && (isIdentifierStart(this.source.charCodeAt(this.index)) || isDecimalDigit(this.source.charAt(this.index)))) {
      throw this.createILLEGAL();
    }

    return new NumericLiteralToken(this.getSlice(start), parseInt(this.getSlice(start).text.substr(1), 8), true);
  };

  Tokenizer.prototype.scanNumericLiteral = function () {
    var ch = this.source.charAt(this.index);
    // assert(ch === "." || "0" <= ch && ch <= "9")
    var start = this.index;

    if (ch === "0") {
      this.index++;
      if (this.index < this.source.length) {
        ch = this.source.charAt(this.index);
        if (ch === "x" || ch === "X") {
          this.index++;
          return this.scanHexLiteral(start);
        } else if ("0" <= ch && ch <= "9") {
          return this.scanOctalLiteral(start);
        }
      } else {
        return new NumericLiteralToken(this.getSlice(start));
      }
    } else if (ch !== ".") {
      // Must be "1'..'9'
      ch = this.source.charAt(this.index);
      while ("0" <= ch && ch <= "9") {
        this.index++;
        if (this.index === this.source.length) {
          return new NumericLiteralToken(this.getSlice(start));
        }
        ch = this.source.charAt(this.index);
      }
    }

    var e = 0;
    if (ch === ".") {
      this.index++;
      if (this.index === this.source.length) {
        return new NumericLiteralToken(this.getSlice(start));
      }

      ch = this.source.charAt(this.index);
      while ("0" <= ch && ch <= "9") {
        e++;
        this.index++;
        if (this.index === this.source.length) {
          return new NumericLiteralToken(this.getSlice(start));
        }
        ch = this.source.charAt(this.index);
      }
    }

    // EOF not reached here
    if (ch === "e" || ch === "E") {
      this.index++;
      if (this.index === this.source.length) {
        throw this.createILLEGAL();
      }

      ch = this.source.charAt(this.index);
      var neg = false;
      if (ch === "+" || ch === "-") {
        neg = ch === "-";
        this.index++;
        if (this.index === this.source.length) {
          throw this.createILLEGAL();
        }
        ch = this.source.charAt(this.index);
      }

      var f = 0;
      if ("0" <= ch && ch <= "9") {
        while ("0" <= ch && ch <= "9") {
          f *= 10;
          f += +ch;
          this.index++;
          if (this.index === this.source.length) {
            break;
          }
          ch = this.source.charAt(this.index);
        }
      } else {
        throw this.createILLEGAL();
      }
      e += neg ? f : -f;
    }

    if (isIdentifierStart(ch.charCodeAt(0))) {
      throw this.createILLEGAL();
    }

    return new NumericLiteralToken(this.getSlice(start));
  };

  Tokenizer.prototype.scanStringLiteral = function () {
    var str = "";

    var quote = this.source.charAt(this.index);
    //  assert((quote === "\"" || quote === """), "String literal must starts with a quote")

    var start = this.index;
    this.index++;

    var octal = false;
    while (this.index < this.source.length) {
      var ch = this.source.charAt(this.index);
      if (ch === quote) {
        this.index++;
        return new StringLiteralToken(this.getSlice(start), str, octal);
      } else if (ch === "\\") {
        this.index++;
        if (this.index === this.source.length) {
          throw this.createILLEGAL();
        }
        ch = this.source.charAt(this.index);
        if (!isLineTerminator(ch.charCodeAt(0))) {
          switch (ch) {
            case "n":
              str += "\n";
              this.index++;
              break;
            case "r":
              str += "\r";
              this.index++;
              break;
            case "t":
              str += "\t";
              this.index++;
              break;
            case "u":
            case "x":
              var restore = this.index;
              var unescaped = undefined;
              this.index++;
              if (this.index >= this.source.length) {
                throw this.createILLEGAL();
              }
              unescaped = ch === "u" ? this.scanHexEscape4() : this.scanHexEscape2();
              if (unescaped >= 0) {
                str += String.fromCharCode(unescaped);
              } else {
                this.index = restore;
                str += ch;
                this.index++;
              }
              break;
            case "b":
              str += "\b";
              this.index++;
              break;
            case "f":
              str += "\f";
              this.index++;
              break;
            case "v":
              str += "\u000b";
              this.index++;
              break;
            default:
              if ("0" <= ch && ch <= "7") {
                octal = true;
                var octLen = 1;
                // 3 digits are only allowed when string starts
                // with 0, 1, 2, 3
                if ("0" <= ch && ch <= "3") {
                  octLen = 0;
                }
                var code = 0;
                while (octLen < 3 && "0" <= ch && ch <= "7") {
                  code *= 8;
                  octLen++;
                  code += ch - "0";
                  this.index++;
                  if (this.index === this.source.length) {
                    throw this.createILLEGAL();
                  }
                  ch = this.source.charAt(this.index);
                }
                str += String.fromCharCode(code);
              } else {
                str += ch;
                this.index++;
              }
          }
        } else {
          this.hasLineTerminatorBeforeNext = true;
          this.index++;
          if (ch === "\r" && this.source.charAt(this.index) === "\n") {
            this.index++;
          }
        }
      } else if (isLineTerminator(ch.charCodeAt(0))) {
        throw this.createILLEGAL();
      } else {
        str += ch;
        this.index++;
      }
    }

    throw this.createILLEGAL();
  };

  Tokenizer.prototype.scanRegExp = function () {
    var start = this.index;
    // ch = this.source.charAt(this.index)

    var str = "";
    str += "/";
    this.index++;

    var terminated = false;
    var classMarker = false;
    while (this.index < this.source.length) {
      var ch = this.source.charAt(this.index);
      if (ch === "\\") {
        str += ch;
        this.index++;
        ch = this.source.charAt(this.index);
        // ECMA-262 7.8.5
        if (isLineTerminator(ch.charCodeAt(0))) {
          throw this.createError(ErrorMessages.UNTERMINATED_REG_EXP);
        }
        str += ch;
        this.index++;
      } else if (isLineTerminator(ch.charCodeAt(0))) {
        throw this.createError(ErrorMessages.UNTERMINATED_REG_EXP);
      } else {
        if (classMarker) {
          if (ch === "]") {
            classMarker = false;
          }
        } else {
          if (ch === "/") {
            terminated = true;
            str += ch;
            this.index++;
            break;
          } else if (ch === "[") {
            classMarker = true;
          }
        }
        str += ch;
        this.index++;
      }
    }

    if (!terminated) {
      throw this.createError(ErrorMessages.UNTERMINATED_REG_EXP);
    }

    while (this.index < this.source.length) {
      var ch = this.source.charAt(this.index);
      if (!isIdentifierPart(ch.charCodeAt(0)) && ch !== "\\") {
        break;
      }
      this.index++;
      str += ch;
    }
    this.lookaheadEnd = this.index;
    return new RegularExpressionLiteralToken(this.getSlice(start), str);
  };

  Tokenizer.prototype.advance = function () {
    var start = this.index;
    this.skipComment();
    this.lastWhitespace = this.getSlice(start);
    this.lookaheadStart = start = this.index;

    if (this.index >= this.source.length) {
      return new EOFToken(this.getSlice(start));
    }

    var charCode = this.source.charCodeAt(this.index);

    if (charCode < 128) {
      if (PUNCTUATOR_START[charCode]) {
        return this.scanPunctuator();
      }

      if (IDENTIFIER_START[charCode]) {
        return this.scanIdentifier();
      }

      // Dot (.) U+002E can also start a floating-polet number, hence the need
      // to check the next character.
      if (charCode === 46) {
        if (this.index + 1 < this.source.length && isDecimalDigit(this.source.charAt(this.index + 1))) {
          return this.scanNumericLiteral();
        }
        return this.scanPunctuator();
      }

      // String literal starts with single quote (U+0027) or double quote (U+0022).
      if (charCode === 39 || charCode === 34) {
        return this.scanStringLiteral();
      }

      if (48 /* '0' */ <= charCode && charCode <= 57 /* '9' */) {
        return this.scanNumericLiteral();
      }

      // Slash (/) U+002F can also start a regex.
      throw this.createILLEGAL();
    } else {
      if (isIdentifierStart(charCode)) {
        return this.scanIdentifier();
      }

      throw this.createILLEGAL();
    }
  };

  Tokenizer.prototype.eof = function () {
    return this.lookahead.type === TokenType.EOS;
  };

  Tokenizer.prototype.lex = function () {
    if (this.prevToken !== null && this.prevToken.type === TokenType.EOS) {
      return this.prevToken;
    }
    this.prevToken = this.lookahead;
    var start = this.index = this.lookaheadEnd;
    this.hasLineTerminatorBeforeNext = false;
    this.lookahead = this.advance();
    this.lookaheadEnd = this.index;
    this.index = start;
    this.tokenIndex++;
    return this.prevToken;
  };

  return Tokenizer;
})();

exports["default"] = Tokenizer;

},{"./errors":3,"./utils":7}],7:[function(require,module,exports){
"use strict";

exports.isRestrictedWord = isRestrictedWord;
exports.isStrictModeReservedWordES5 = isStrictModeReservedWordES5;
exports.isDecimalDigit = isDecimalDigit;
exports.isLineTerminator = isLineTerminator;
exports.isWhitespace = isWhitespace;
exports.isIdentifierStart = isIdentifierStart;
exports.isIdentifierPart = isIdentifierPart;
exports.getHexValue = getHexValue;
/**
 * Copyright 2014 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var STRICT_MODE_RESERVED_WORD_ES5 = ["implements", "interface", "package", "private", "protected", "public", "static", "yield", "false", "null", "true", "let", "if", "in", "do", "var", "for", "new", "try", "this", "else", "case", "void", "with", "enum", "while", "break", "catch", "throw", "const", "class", "super", "return", "typeof", "delete", "switch", "export", "import", "default", "finally", "extends", "function", "continue", "debugger", "instanceof"];

// See also tools/generate-unicode-regex.py.
var Regex = {
  NonAsciiIdentifierStart: new RegExp("[\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0-\u08b2\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua7ad\ua7b0\ua7b1\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab5f\uab64\uab65\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]"),
  NonAsciiIdentifierPart: new RegExp("[\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0-\u08b2\u08e4-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09e6-\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1\u0cf2\u0d01-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19d9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1cf8\u1cf9\u1d00-\u1df5\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u200c\u200d\u203f\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua69d\ua69f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua7ad\ua7b0\ua7b1\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua900-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab5f\uab64\uab65\uabc0-\uabea\uabec\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2d\ufe33\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]")
};

function isRestrictedWord(name) {
  return "eval" === name || "arguments" === name;
}

function isStrictModeReservedWordES5(name) {
  return STRICT_MODE_RESERVED_WORD_ES5.indexOf(name) !== -1;
}

function isDecimalDigit(ch) {
  return "0" <= ch && ch <= "9";
}

function isLineTerminator(ch) {
  return (ch == 13) || (ch == 10) || (ch == 8232) || (ch == 8233);
}

function isWhitespace(ch) {
  return (ch === 32) || (ch === 9) || (ch === 11) || (ch === 12) || (ch === 160) || (ch >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(ch) >= 0);
}

function isIdentifierStart(ch) {
  return (ch === 36) || (ch === 95) || // $ (dollar) and _ (underscore)
  (ch >= 65 && ch <= 90) || // A..Z
  (ch >= 97 && ch <= 122) || // a..z
  (ch === 92) || // \ (backslash)
  ((ch >= 128) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
}

function isIdentifierPart(ch) {
  return (ch === 36) || (ch === 95) || // $ (dollar) and _ (underscore)
  (ch >= 65 && ch <= 90) || // A..Z
  (ch >= 97 && ch <= 122) || // a..z
  (ch >= 48 && ch <= 57) || // 0..9
  (ch === 92) || // \ (backslash)
  ((ch >= 128) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
}

function getHexValue(rune) {
  if ("0" <= rune && rune <= "9") {
    return rune.charCodeAt(0) - 48;
  }
  if ("a" <= rune && rune <= "f") {
    return rune.charCodeAt(0) - 87;
  }
  if ("A" <= rune && rune <= "F") {
    return rune.charCodeAt(0) - 55;
  }
  return -1;
}

},{}],8:[function(require,module,exports){
module.exports = function (root) {
    var res, obj, arr, indent;

    obj = function (tree) {
        var ret, child;
        ret = '<span class="redrom-syn">{</span>\n';
        indent += '  ';
        Object.keys(tree).forEach(function (key) {
            ret += '<span class="redrom-key">' + indent + key + '</span>';
            ret += '<span class="redrom-syn">: </span>';
            ret += '<span class="redrom-val">';
            child = Object.prototype.toString.call(tree[key]);
            if (child === '[object Object]') {
                ret += obj(tree[key]);
            } else if (child === '[object Array]') {
                ret += arr(tree[key]);
            } else {
                ret += tree[key] + '</span>\n';
            }
        });
        indent = indent.slice(0, -2);
        ret += '<span class="redrom-syn">' + indent + '}</span>\n';
        return ret;
    };

    arr = function (tree) {
        var ret, child;
        if (tree.length === 0) return '<span class="redrom-syn">[]</span>\n';
        ret = '<span class="redrom-syn">[</span>\n';
        indent += '  ';
        ret += indent;
        tree.forEach(function (e, i) {
            child = Object.prototype.toString.call(e);
            if (child === '[object Object]') {
                ret += obj(e);
            } else if (child === '[object Array]') {
                ret += arr(e);
            } else {
                ret += e + '</span>\n';
            }
            if (i < tree.length - 1) {
                ret += indent;
            }
        });
        indent = indent.slice(0, -2);
        ret += '<span class="redrom-syn">' + indent + ']</span>\n';
        return ret;
    };

    indent = '';
    res = obj(root);
    return res;
};

},{}]},{},[1]);
